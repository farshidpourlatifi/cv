---
/**
 * PaperCanvasExact Component
 *
 * Paper.js canvas with exact shapes from bg.svg design
 * All positions, colors, and sizes match the original Figma design
 */
---

<div id="geometric-canvas-container" class="paper-canvas-container">
  <canvas id="geometric-canvas" resize></canvas>
</div>

<style>
  .paper-canvas-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
  }

  #geometric-canvas {
    width: 100%;
    height: 100%;
    pointer-events: auto;
  }
</style>

<script>
  import paper from 'paper';

  // Initialize Paper.js - run immediately since Astro scripts are deferred by default
  function initPaperCanvas() {
    const canvas = document.getElementById('geometric-canvas') as HTMLCanvasElement;
    if (!canvas) {
      console.error('Canvas not found!');
      return;
    }

    console.log('Initializing Paper.js...');

    // Setup Paper.js
    paper.setup(canvas);

    console.log('Paper.js setup complete');

    // Colors from the SVG design
    const colors = {
      primaryLight: '#004B72',
      secondary: '#3E9FD4',
      accent: '#F0000F',
      accentDark: '#E00514',
      tertiary: '#006BA5',
      white: '#FFFFFF',
    };

    // Generate shapes within a diagonal sine wave band (bottom-left to top-right)
    const generateShapesInDiagonalBand = () => {
      const generatedShapes: any[] = [];
      const minDistance = 50; // Minimum distance between shapes (lower = more dense)

      // Band parameters
      const bandWidth = 300; // Width of the band (perpendicular to diagonal)
      const sineAmplitude = 100; // Amplitude of sine wave oscillation
      const sineFrequency = 0.004; // Frequency of sine wave

      // Diagonal line from bottom-left to top-right
      const startPoint = { x: 0, y: paper.view.size.height };
      const endPoint = { x: paper.view.size.width, y: 0 };

      // Calculate diagonal distance
      const diagonalLength = Math.sqrt(
        Math.pow(endPoint.x - startPoint.x, 2) +
        Math.pow(endPoint.y - startPoint.y, 2)
      );

      // Unit vector along diagonal
      const directionX = (endPoint.x - startPoint.x) / diagonalLength;
      const directionY = (endPoint.y - startPoint.y) / diagonalLength;

      // Perpendicular vector (for band width)
      const perpX = -directionY;
      const perpY = directionX;

      // Shape types to cycle through for equal distribution
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const sizes = { circle: [15, 20, 10], rect: [15, 25, 20], triangle: [20, 15, 25] };
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const strokeWidthOptions = [1, 2, 5];

      // Counters for equal distribution
      let shapeCounter = 0;
      let colorCounter = 0;
      let strokeCounter = 0;

      // Check if position is too close to existing shapes
      const isTooClose = (x: number, y: number, existing: any[]) => {
        return existing.some(shape => {
          const dx = shape.x - x;
          const dy = shape.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });
      };

      // Generate shapes along the diagonal band
      const spacing = 5; // Spacing along the diagonal (lower = more attempts = more dense)

      for (let t = 50; t < diagonalLength - 50; t += spacing + Math.random() * 3) {
        // Position along the diagonal
        const baseX = startPoint.x + directionX * t;
        const baseY = startPoint.y + directionY * t;

        // Sine wave offset (oscillates perpendicular to diagonal)
        const sineOffset = Math.sin(t * sineFrequency) * sineAmplitude;

        // Random offset within band width
        const bandOffset = (Math.random() - 0.5) * bandWidth + sineOffset;

        // Final position
        const x = baseX + perpX * bandOffset;
        const y = baseY + perpY * bandOffset;

        // Check bounds and overlap (reduced padding for more density)
        if (x >= 30 && x <= paper.view.size.width - 30 &&
            y >= 30 && y <= paper.view.size.height - 30 &&
            !isTooClose(x, y, generatedShapes)) {

          // Equal distribution: cycle through shape types
          const type = shapeTypes[shapeCounter % shapeTypes.length];
          shapeCounter++;

          const sizeOptions = sizes[type as keyof typeof sizes];
          const size = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];

          // Equal distribution: cycle through colors
          const strokeColor = colorOptions[colorCounter % colorOptions.length];
          colorCounter++;

          // Equal distribution: cycle through stroke widths
          const strokeWidth = strokeWidthOptions[strokeCounter % strokeWidthOptions.length];
          strokeCounter++;

          // Random rotation
          const rotation = Math.random() * 360;

          // Add shape
          if (type === 'circle') {
            generatedShapes.push({
              type: 'circle',
              x, y,
              radius: size,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'rect') {
            generatedShapes.push({
              type: 'rect',
              x, y,
              width: size,
              height: size,
              radius: Math.random() > 0.5 ? 2.5 : 4.5,
              rotation,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'triangle') {
            generatedShapes.push({
              type: 'triangle',
              x, y,
              size,
              rotation,
              strokeColor,
              strokeWidth
            });
          }
        }
      }

      return generatedShapes;
    };

    const shapesData = generateShapesInDiagonalBand();

    // Draw visible sine wave band for debugging/visualization
    const drawSineWaveBand = () => {
      // Band parameters (must match generation parameters)
      const bandWidth = 300;
      const sineAmplitude = 100;
      const sineFrequency = 0.004;

      // Diagonal line from bottom-left to top-right
      const startPoint = { x: 0, y: paper.view.size.height };
      const endPoint = { x: paper.view.size.width, y: 0 };

      // Calculate diagonal distance
      const diagonalLength = Math.sqrt(
        Math.pow(endPoint.x - startPoint.x, 2) +
        Math.pow(endPoint.y - startPoint.y, 2)
      );

      // Unit vector along diagonal
      const directionX = (endPoint.x - startPoint.x) / diagonalLength;
      const directionY = (endPoint.y - startPoint.y) / diagonalLength;

      // Perpendicular vector (for band width)
      const perpX = -directionY;
      const perpY = directionX;

      // Draw center sine wave line
      const centerLine = new paper.Path();
      centerLine.strokeColor = new paper.Color('#FF0000');
      centerLine.strokeWidth = 2;
      centerLine.opacity = 0.3;
      centerLine.dashArray = [10, 5];

      // Draw upper boundary
      const upperBoundary = new paper.Path();
      upperBoundary.strokeColor = new paper.Color('#00FF00');
      upperBoundary.strokeWidth = 1;
      upperBoundary.opacity = 0.2;
      upperBoundary.dashArray = [5, 5];

      // Draw lower boundary
      const lowerBoundary = new paper.Path();
      lowerBoundary.strokeColor = new paper.Color('#00FF00');
      lowerBoundary.strokeWidth = 1;
      lowerBoundary.opacity = 0.2;
      lowerBoundary.dashArray = [5, 5];

      // Generate points along the diagonal
      for (let t = 0; t <= diagonalLength; t += 5) {
        // Position along the diagonal
        const baseX = startPoint.x + directionX * t;
        const baseY = startPoint.y + directionY * t;

        // Sine wave offset
        const sineOffset = Math.sin(t * sineFrequency) * sineAmplitude;

        // Center line point
        const centerX = baseX + perpX * sineOffset;
        const centerY = baseY + perpY * sineOffset;
        centerLine.add(new paper.Point(centerX, centerY));

        // Upper boundary point
        const upperOffset = sineOffset + bandWidth / 2;
        const upperX = baseX + perpX * upperOffset;
        const upperY = baseY + perpY * upperOffset;
        upperBoundary.add(new paper.Point(upperX, upperY));

        // Lower boundary point
        const lowerOffset = sineOffset - bandWidth / 2;
        const lowerX = baseX + perpX * lowerOffset;
        const lowerY = baseY + perpY * lowerOffset;
        lowerBoundary.add(new paper.Point(lowerX, lowerY));
      }

      // Return paths so they can be toggled later
      return { centerLine, upperBoundary, lowerBoundary };
    };

    // Draw the sine wave visualization
    const sineWaveGuides = drawSineWaveBand();

    // TOGGLE GUIDE VISIBILITY: Set to false to hide the sine wave guides
    const showGuides = true;
    if (!showGuides) {
      sineWaveGuides.centerLine.visible = false;
      sineWaveGuides.upperBoundary.visible = false;
      sineWaveGuides.lowerBoundary.visible = false;
    }

    // Fallback to original shapes if generation fails
    const originalShapesData = [
      // CENTER SHAPES - positioned around viewport center (683, 386)
      // Top circle
      { type: 'circle', x: 712.738, y: 271.64, radius: 69.5, strokeColor: colors.primaryLight, strokeWidth: 5 },
      // Bottom circle
      { type: 'circle', x: 670.738, y: 524.64, radius: 69.5, strokeColor: colors.primaryLight, strokeWidth: 5 },
      // Rectangle (square)
      { type: 'rect', x: 493.849 + 62, y: 270.26 + 62, width: 124, height: 124, radius: 17.5, rotation: -16.6403, strokeColor: colors.primaryLight, strokeWidth: 5 },
      { type: 'rect', x: 848.255, y: 331.91, width: 24, height: 24, radius: 2.5, rotation: 22.6612, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'rect', x: 902.214, y: 376.752, width: 40, height: 40, radius: 2.5, rotation: -34.4661, strokeColor: colors.accent, strokeWidth: 5 },

      // More circles
      { type: 'circle', x: 1083.24, y: 154.14, radius: 23, strokeColor: colors.secondary, strokeWidth: 5 },
      { type: 'circle', x: 1043.74, y: 239.64, radius: 15, strokeColor: colors.white, strokeWidth: 2 },
      { type: 'circle', x: 854.738, y: 418.64, radius: 15, strokeColor: colors.white, strokeWidth: 2 },

      // CENTER SHAPE - Triangle
      { type: 'triangle', x: 811.616, y: 439.128, size: 40, rotation: 15, strokeColor: colors.primaryLight, strokeWidth: 5 },
      { type: 'triangle', x: 1155.61, y: 135.053, size: 20, rotation: 0, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'triangle', x: 839.168, y: 259.237, size: 25, rotation: 45, strokeColor: colors.accent, strokeWidth: 5 },

      // More rectangles
      { type: 'rect', x: 866.216, y: 233.772, width: 24, height: 24, radius: 2.5, rotation: -34.6751, strokeColor: colors.tertiary, strokeWidth: 5 },
      { type: 'rect', x: 980.53, y: 168.411, width: 40, height: 40, radius: 2.5, rotation: -7.1514, strokeColor: colors.white, strokeWidth: 5 },

      // More circles
      { type: 'circle', x: 981.238, y: 309.14, radius: 23, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'circle', x: 898.738, y: 303.64, radius: 15.5, strokeColor: colors.accent, strokeWidth: 1 },

      // Bottom left shapes
      { type: 'rect', x: 396.18, y: 505.294, width: 28, height: 28, radius: 4.5, rotation: 22.6612, strokeColor: colors.tertiary, strokeWidth: 1 },
      { type: 'rect', x: 271.433, y: 610.235, width: 44, height: 44, radius: 4.5, rotation: -34.4661, strokeColor: colors.white, strokeWidth: 1 },
      { type: 'circle', x: 388.238, y: 591.14, radius: 23, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'circle', x: 301.738, y: 681.64, radius: 13.5, strokeColor: colors.accent, strokeWidth: 5 },

      // Middle shapes
      { type: 'triangle', x: 515.168, y: 375.237, size: 30, rotation: 30, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'rect', x: 527.216, y: 521.772, width: 24, height: 24, radius: 2.5, rotation: -34.6751, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'rect', x: 466.855, y: 552.109, width: 43, height: 43, radius: 4, rotation: -7.1514, strokeColor: colors.accent, strokeWidth: 2 },
      { type: 'circle', x: 506.238, y: 460.14, radius: 24.5, strokeColor: colors.tertiary, strokeWidth: 2 },
      { type: 'circle', x: 429.738, y: 463.64, radius: 13.5, strokeColor: colors.white, strokeWidth: 5 },

      // Right side shapes
      { type: 'rect', x: 1349.49, y: 92.4186, width: 24, height: 24, radius: 2.5, rotation: -141.68, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'rect', x: 1332.67, y: 39.6765, width: 40, height: 40, radius: 2.5, rotation: 161.193, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'circle', x: 1120.17, y: 252.076, radius: 23, strokeColor: colors.secondary, strokeWidth: 5 },
      { type: 'circle', x: 1132.46, y: 100.364, radius: 15, strokeColor: colors.white, strokeWidth: 2 },

      // Lines
      { type: 'line', x1: 1033.27, y1: 289.64, x2: 1043.88, y2: 300.246, strokeColor: colors.accentDark, strokeWidth: 5 },
      { type: 'line', x1: 1159.92, y1: 83.182, x2: 1152.57, y2: 70.1062, strokeColor: colors.accentDark, strokeWidth: 5 },
      { type: 'line', x1: 439.777, y1: 413.447, x2: 453.622, y2: 419.218, strokeColor: colors.accentDark, strokeWidth: 5 },

      // Bottom shapes
      { type: 'rect', x: 175.891, y: 772.016, width: 28, height: 28, radius: 4.5, rotation: -103.529, strokeColor: colors.tertiary, strokeWidth: 1 },
      { type: 'rect', x: 139.997, y: 637.01, width: 44, height: 44, radius: 4.5, rotation: 174.929, strokeColor: colors.white, strokeWidth: 1 },
      { type: 'circle', x: 117.317, y: 718.219, radius: 23, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'circle', x: 171.788, y: 667.689, radius: 13.5, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'rect', x: 37.1284, y: 665.948, width: 43, height: 43, radius: 4, rotation: -150.891, strokeColor: colors.accent, strokeWidth: 2 },
      { type: 'circle', x: 40.7876, y: 756.689, radius: 13.5, strokeColor: colors.white, strokeWidth: 5 },

      // Additional middle triangles
      { type: 'triangle', x: 924.924, y: 158.046, size: 20, rotation: 60, strokeColor: colors.accent, strokeWidth: 1 },
      { type: 'triangle', x: 952.3, y: 217.749, size: 25, rotation: -30, strokeColor: colors.tertiary, strokeWidth: 2 },
      { type: 'triangle', x: 355.151, y: 653.265, size: 20, rotation: 90, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'triangle', x: 475.147, y: 503.033, size: 22, rotation: 120, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'triangle', x: 217.204, y: 662.321, size: 28, rotation: -45, strokeColor: colors.secondary, strokeWidth: 5 },
      { type: 'triangle', x: 226.481, y: 612.15, size: 18, rotation: 180, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'triangle', x: 17.1423, y: 703.352, size: 25, rotation: 270, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'triangle', x: 289.913, y: 555.278, size: 30, rotation: 15, strokeColor: colors.secondary, strokeWidth: 5 },
      { type: 'triangle', x: 1087.4, y: 222.868, size: 22, rotation: -60, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'triangle', x: 1228.73, y: 239.136, size: 26, rotation: 45, strokeColor: colors.accent, strokeWidth: 1 },
      { type: 'triangle', x: 1218.49, y: 174.26, size: 24, rotation: 135, strokeColor: colors.tertiary, strokeWidth: 2 },

      // More rectangles
      { type: 'rect', x: 1323.43, y: 178.508, width: 24, height: 24, radius: 2.5, rotation: 160.984, strokeColor: colors.tertiary, strokeWidth: 5 },
      { type: 'rect', x: 1177.99, y: 214.147, width: 40, height: 40, radius: 2.5, rotation: -171.493, strokeColor: colors.white, strokeWidth: 5 },

      // Final circles
      { type: 'circle', x: 1215.29, y: 78.4505, radius: 23, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'circle', x: 1293.25, y: 106.014, radius: 15.5, strokeColor: colors.accent, strokeWidth: 1 },
    ];

    // Create shapes
    const shapes: paper.Path[] = [];

    shapesData.forEach(shapeData => {
      let shape: paper.Path | paper.Shape;

      switch(shapeData.type) {
        case 'circle':
          shape = new paper.Path.Circle({
            center: [shapeData.x, shapeData.y],
            radius: shapeData.radius,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          break;

        case 'rect':
          shape = new paper.Path.Rectangle({
            point: [shapeData.x - shapeData.width/2, shapeData.y - shapeData.height/2],
            size: [shapeData.width, shapeData.height],
            radius: shapeData.radius || 0,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          // Set position to center after creation
          shape.position = new paper.Point(shapeData.x, shapeData.y);
          if (shapeData.rotation) {
            shape.rotate(shapeData.rotation, shape.position);
          }
          break;

        case 'triangle':
          shape = new paper.Path.RegularPolygon({
            center: [shapeData.x, shapeData.y],
            sides: 3,
            radius: shapeData.size,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          if (shapeData.rotation) {
            shape.rotate(shapeData.rotation);
          }
          break;

        case 'line':
          shape = new paper.Path.Line({
            from: [shapeData.x1, shapeData.y1],
            to: [shapeData.x2, shapeData.y2],
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
            strokeCap: 'round',
          });
          break;

        default:
          return;
      }

      // Store original position and lifecycle data
      shape.data = {
        originalPosition: shape.position.clone(),
        originalRotation: shapeData.rotation || 0,
        floatPhaseY: Math.random() * Math.PI * 2, // Y-axis phase
        floatPhaseX: Math.random() * Math.PI * 2, // X-axis phase (different)
        rotationSpeed: (Math.random() - 0.5) * 0.02, // Slightly more visible rotation
        floatSpeedY: 0.02 + Math.random() * 0.02, // Increased Y speed
        floatSpeedX: 0.01 + Math.random() * 0.01, // Increased X speed
        amplitudeY: 1 + Math.random() * 3, // Random Y amplitude (5-8px)
        amplitudeX: 1 + Math.random() * .03, // Random X amplitude (6-10px)
        // Lifecycle properties
        age: 0,
        lifespan: 300 + Math.random() * 500, // Random lifespan (300-800 frames, ~5-13 seconds at 60fps)
        baseX: shapeData.x, // Original X for respawn
        baseY: shapeData.y, // Original Y for respawn
        shapeType: shapeData.type,
      };

      shapes.push(shape);
    });

    console.log(`Created ${shapes.length} shapes`);

    // Counters for equal distribution of shapes, colors, and stroke widths
    let shapeTypeCounter = 0;
    let colorCounter = 0;
    let strokeWidthCounter = 0;

    // Easing functions for smoother motion
    const easeInOutSine = (t: number) => -(Math.cos(Math.PI * t) - 1) / 2;
    const easeInOutQuad = (t: number) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    const easeInOutCubic = (t: number) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

    // Helper function to regenerate a shape with equal distribution
    const regenerateShape = (shape: paper.Path, index: number) => {
      const data = shape.data;

      // Position jitter (within ±30px of original position)
      const jitterX = (Math.random() - 0.5) * 60;
      const jitterY = (Math.random() - 0.5) * 60;
      const newX = data.baseX + jitterX;
      const newY = data.baseY + jitterY;

      // Equal distribution of shape types (cycle through)
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const newType = shapeTypes[shapeTypeCounter % shapeTypes.length];
      shapeTypeCounter++;

      // Equal distribution of sizes for each type
      const sizes = { circle: [15, 20, 10], rect: [15, 25, 20], triangle: [20, 15, 25] };
      const sizeOptions = sizes[newType as keyof typeof sizes];
      const sizeIndex = Math.floor(Math.random() * sizeOptions.length); // Keep size random within type
      const newSize = sizeOptions[sizeIndex] || 20;

      // Equal distribution of colors (cycle through)
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const newColor = colorOptions[colorCounter % colorOptions.length];
      colorCounter++;

      // Equal distribution of stroke widths (cycle through)
      const strokeWidthOptions = [1, 2, 5];
      const newStrokeWidth = strokeWidthOptions[strokeWidthCounter % strokeWidthOptions.length];
      strokeWidthCounter++;

      // Random rotation
      const newRotation = Math.random() * 360;

      // Remove old shape
      shape.remove();

      // Create new shape
      let newShape: paper.Path | paper.Shape;

      switch(newType) {
        case 'circle':
          newShape = new paper.Path.Circle({
            center: [newX, newY],
            radius: newSize,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          break;

        case 'rect':
          newShape = new paper.Path.Rectangle({
            point: [newX - newSize/2, newY - newSize/2],
            size: [newSize, newSize],
            radius: Math.random() > 0.5 ? 2.5 : 4.5,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          newShape.position = new paper.Point(newX, newY);
          newShape.rotate(newRotation, newShape.position);
          break;

        case 'triangle':
          newShape = new paper.Path.RegularPolygon({
            center: [newX, newY],
            sides: 3,
            radius: newSize,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          newShape.rotate(newRotation);
          break;

        default:
          return;
      }

      // Reset lifecycle data with new randomized values
      newShape.data = {
        originalPosition: newShape.position.clone(),
        originalRotation: newRotation,
        floatPhaseY: Math.random() * Math.PI * 2,
        floatPhaseX: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.02,
        floatSpeedY: 0.02 + Math.random() * 0.02,
        floatSpeedX: 0.01 + Math.random() * 0.01,
        amplitudeY: 1 + Math.random() * 3,
        amplitudeX: 1 + Math.random() * .03,
        age: 0,
        lifespan: 300 + Math.random() * 500, // New random lifespan
        baseX: data.baseX, // Keep original base position
        baseY: data.baseY,
        shapeType: newType,
      };

      // Replace in shapes array
      shapes[index] = newShape;
    };

    // Organic floating animations - each shape moves independently in X and Y with easing
    paper.view.onFrame = (event: any) => {
      const time = event.count;

      shapes.forEach((shape, index) => {
        // Regenerate before incrementing age if lifecycle is complete
        if (shape.data.age >= shape.data.lifespan) {
          regenerateShape(shape, index);
          // Get the newly regenerated shape
          shape = shapes[index];
        }

        // Increment age
        shape.data.age++;

        // Calculate fade in/out opacity based on lifecycle (linear)
        const fadeInDuration = 30; // Fade in over 30 frames (~0.5 second at 60fps)
        const fadeOutDuration = 30; // Fade out over 30 frames
        const age = shape.data.age;
        const lifespan = shape.data.lifespan;

        let opacity = 1;

        // Fade in at the beginning (linear)
        if (age <= fadeInDuration) {
          opacity = age / fadeInDuration;
        }
        // Fade out at the end (linear)
        else if (age >= lifespan - fadeOutDuration) {
          opacity = Math.max(0, (lifespan - age) / fadeOutDuration);
        }

        shape.opacity = opacity;

        // Raw sine wave values (oscillating between -1 and 1)
        const rawSinY = Math.sin(time * shape.data.floatSpeedY + shape.data.floatPhaseY);
        const rawSinX = Math.sin(time * shape.data.floatSpeedX + shape.data.floatPhaseX);

        // Normalize to 0-1 range for easing function
        const normalizedY = (rawSinY + 1) / 2; // Convert -1..1 to 0..1
        const normalizedX = (rawSinX + 1) / 2;

        // Apply easing (creates smoother acceleration/deceleration)
        const easedY = easeInOutSine(normalizedY);
        const easedX = easeInOutSine(normalizedX);

        // Convert back to -1..1 range and apply amplitude
        const floatOffsetY = (easedY * 2 - 1) * shape.data.amplitudeY;
        const floatOffsetX = (easedX * 2 - 1) * shape.data.amplitudeX;

        // Apply both movements
        shape.position.x = shape.data.originalPosition.x + floatOffsetX;
        shape.position.y = shape.data.originalPosition.y + floatOffsetY;

        // Gentle rotation with easing
        const rotationEase = easeInOutSine(normalizedY);
        shape.rotate(shape.data.rotationSpeed * 60 * (rotationEase * 2 - 1));
      });
    };

    console.log('Animation loop started');

    // Handle resize
    window.addEventListener('resize', () => {
      paper.view.viewSize = new paper.Size(window.innerWidth, window.innerHeight);
    });
  }

  // Run when DOM is ready
  console.log('Script loaded! readyState:', document.readyState);

  if (document.readyState === 'loading') {
    console.log('Waiting for DOMContentLoaded...');
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded fired!');
      initPaperCanvas();
    });
  } else {
    console.log('DOM already ready, initializing immediately');
    initPaperCanvas();
  }
</script>