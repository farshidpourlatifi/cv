---
/**
 * PaperCanvasExact Component
 *
 * Paper.js canvas with exact shapes from bg.svg design
 * All positions, colors, and sizes match the original Figma design
 */
---

<div id="geometric-canvas-container" class="paper-canvas-container">
  <canvas id="geometric-canvas" resize></canvas>
</div>

<style>
  .paper-canvas-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
  }

  #geometric-canvas {
    width: 100%;
    height: 100%;
    pointer-events: auto;
  }
</style>

<script>
  import paper from 'paper';

  // Initialize Paper.js - run immediately since Astro scripts are deferred by default
  function initPaperCanvas() {
    const canvas = document.getElementById('geometric-canvas') as HTMLCanvasElement;
    if (!canvas) {
      console.error('Canvas not found!');
      return;
    }

    console.log('Initializing Paper.js...');

    // Setup Paper.js
    paper.setup(canvas);

    console.log('Paper.js setup complete');

    // Helper function to get CSS variable value
    const getCSSVariable = (variableName: string): string => {
      return getComputedStyle(document.documentElement)
        .getPropertyValue(variableName)
        .trim();
    };

    // Colors - using your Figma Design System from BaseLayout.astro
    const colors = {
      primary: getCSSVariable('--color-primary') || '#0A3A52',              // Darkest Blue - Primary BG
      primaryLight: getCSSVariable('--color-primary-light') || '#004B72',   // Dark Blue
      secondary: getCSSVariable('--color-secondary') || '#006BA5',          // Medium Blue - Interactive
      secondaryLight: getCSSVariable('--color-secondary-light') || '#3E9FD4', // Cyan - Highlights & Titles
      tertiary: getCSSVariable('--color-secondary') || '#006BA5',           // Alias for secondary (backward compatibility)
      accent: getCSSVariable('--color-accent') || '#F0000F',                // Primary Red - CTA
      accentDark: getCSSVariable('--color-accent-dark') || '#BF0B16',       // Dark Red
      lineAccent: getCSSVariable('--color-line-accent') || '#E00514',       // Line accents
      white: getCSSVariable('--color-white') || '#FFFFFF',
      background: getCSSVariable('--color-primary') || '#0A3A52',           // Use primary color as background (matches page bg)
    };

    // Shape animation configuration - adjust shape movement and behavior here
    const shapeConfig = {
      // Rotation
      rotationSpeed: {
        min: -0.005,               // Minimum rotation speed (counter-clockwise)
        max: 0.005,                // Maximum rotation speed (clockwise)
      },

      // Floating movement
      floatSpeed: {
        yMin: 0.01,               // Minimum Y-axis float speed
        yMax: 0.03,               // Maximum Y-axis float speed (0.02 + 0.02)
        xMin: 0.0,               // Minimum X-axis float speed
        xMax: 0.0,               // Maximum X-axis float speed (0.01 + 0.01)
      },

      // Float amplitude (movement distance)
      amplitude: {
        yMin: 1,                  // Minimum Y amplitude
        yMax: 4,                  // Maximum Y amplitude (1 + 3)
        xMin: 1,                  // Minimum X amplitude
        xMax: 1.03,               // Maximum X amplitude (1 + 0.03)
      },

      // Blur effect
      blur: {
        enabled: false,            // Enable blur on some shapes
        probability: 0.3,         // 30% chance a shape will have blur
        amount: 8,                // Blur radius in pixels
      },

      // Lifecycle
      lifespan: {
        min: 300,                 // Minimum lifespan in frames (~5 seconds at 60fps)
        max: 800,                 // Maximum lifespan in frames (300 + 500, ~13 seconds)
      },

      // Firing behavior
      firing: {
        decay: 0.08,              // How fast the glow fades
        cooldown: 180,            // Minimum frames between fires (3 seconds at 60fps)
        lifespanExtension: 100,   // Frames added to lifespan when firing (~1.7 seconds)
      },

      // Shape sizes (three variants per shape type)
      sizes: {
        circle: [14, 18, 12],     // Circle radius variants
        rect: [15, 22, 18],       // Rectangle size variants
        triangle: [17, 14, 20],   // Triangle size variants
      },

      // Shape distribution and positioning
      distribution: {
        minDistance: 50,          // Minimum distance between shapes (lower = more dense)
        bandWidth: 300,           // Width of the band (perpendicular to diagonal)
        sineAmplitude: 100,       // Amplitude of sine wave oscillation
        sineFrequency: 0.004,     // Frequency of sine wave
        spacing: 5,               // Spacing along diagonal (lower = more dense)
        spacingRandomness: 3,     // Random variation in spacing (0-3)
        edgeMargin: 50,           // Margin from viewport edges at start/end
        boundsInset: 30,          // Minimum distance from viewport edges for shapes
      },

      // Shape appearance
      appearance: {
        strokeWidthOptions: [2, 3, 5], // Available stroke width variants
        initialRotation: 360,     // Random rotation range (0-360 degrees)
      },

      // Shape lifecycle and fading
      fade: {
        fadeInDuration: 30,       // Fade in duration in frames (~0.5s at 60fps)
        fadeOutDuration: 30,      // Fade out duration in frames (~0.5s at 60fps)
      },

      // Firing effects
      fireEffects: {
        randomFireProbability: 0.003,  // Chance per frame for random firing (0.003 = 0.3%)
        glowStrokeMultiplier: 3,       // How much stroke width increases when glowing
        glowBrightnessMultiplier: 0.3, // How much brightness increases when glowing
      },

      // Regeneration
      regeneration: {
        jitterX: 0,               // Position jitter on X axis when regenerating (±pixels)
        jitterY: 0,               // Position jitter on Y axis when regenerating (±pixels)
        defaultSizeFallback: 20,  // Default size if no size variant found
      },
    };

    // Connection line configuration - adjust all connection properties here
    const connectionConfig = {
      // Connection creation
      maxDistance: 130,          // Maximum distance to connect shapes
      probability: 0.5,          // Probability of creating a connection (0-1)

      // Static connection line appearance
      staticOpacity: 0.4,        // Base opacity of connection lines (0-1)
      staticStrokeWidth: .5,     // Line thickness
      staticDashArray: [2, 4],    // Dash pattern [dash, gap]

      // Pulsing animation for connection lines
      pulseBaseOpacity: 0.7,     // Minimum opacity during pulse
      pulseAmount: 0.3,           // How much the pulse adds to opacity

      // Traveling pulse animation
      pulseSpeed: {
        min: 0.02,               // Minimum pulse travel speed (slower)
        max: 0.05,                // Maximum pulse travel speed (faster)
      },

      // Traveling pulse stroke width animation
      pulseStrokeWidth: {
        start: 0.1,               // Starting width (thin)
        peak: 2,                  // Peak width (thick)
        end: .1,                   // Ending width (medium)
      },

      // Pulse blur effect
      pulseBlur: {
        enabled: false,            // Enable blur on traveling pulses
        amount: 10,               // Blur radius in pixels
      },

      // Phase durations for pulse animation
      pulseGrowthPhase: 0.5,      // Duration of growth phase (0-1)
      pulseFadePhase: 0.5,        // Duration of fade/shrink phase (0-1)

      // Pulse visual effects
      pulseVisuals: {
        opacityMultiplier: 0.5,   // How much base pulse opacity affects final value (0-1)
        opacityOffset: 0.5,       // Offset added to pulse opacity calculation (0-1)
      },

      // Connection data initialization
      initialization: {
        maxAge: 60,               // Maximum initial age for staggered animation
        initialFireTime: -1000,   // Initial lastFireTime value (frame number)
      },
    };

    // Generate shapes within a diagonal sine wave band (bottom-left to top-right)
    const generateShapesInDiagonalBand = () => {
      const generatedShapes: any[] = [];
      // Shape distribution parameters from config
      const minDistance = shapeConfig.distribution.minDistance;
      const bandWidth = shapeConfig.distribution.bandWidth;
      const sineAmplitude = shapeConfig.distribution.sineAmplitude;
      const sineFrequency = shapeConfig.distribution.sineFrequency;

      // Diagonal line from bottom-left to top-right
      const startPoint = { x: 0, y: paper.view.size.height };
      const endPoint = { x: paper.view.size.width, y: 0 };

      // Calculate diagonal distance
      const diagonalLength = Math.sqrt(
        Math.pow(endPoint.x - startPoint.x, 2) +
        Math.pow(endPoint.y - startPoint.y, 2)
      );

      // Unit vector along diagonal
      const directionX = (endPoint.x - startPoint.x) / diagonalLength;
      const directionY = (endPoint.y - startPoint.y) / diagonalLength;

      // Perpendicular vector (for band width)
      const perpX = -directionY;
      const perpY = directionX;

      // Shape types to cycle through for equal distribution
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const sizes = shapeConfig.sizes;
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const strokeWidthOptions = shapeConfig.appearance.strokeWidthOptions;

      // Counters for equal distribution
      let shapeCounter = 0;
      let colorCounter = 0;
      let strokeCounter = 0;

      // Check if position is too close to existing shapes
      const isTooClose = (x: number, y: number, existing: any[]) => {
        return existing.some(shape => {
          const dx = shape.x - x;
          const dy = shape.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });
      };

      // Generate shapes along the diagonal band
      const spacing = shapeConfig.distribution.spacing;
      const edgeMargin = shapeConfig.distribution.edgeMargin;
      const spacingRandomness = shapeConfig.distribution.spacingRandomness;

      for (let t = edgeMargin; t < diagonalLength - edgeMargin; t += spacing + Math.random() * spacingRandomness) {
        // Position along the diagonal
        const baseX = startPoint.x + directionX * t;
        const baseY = startPoint.y + directionY * t;

        // Sine wave offset (oscillates perpendicular to diagonal)
        const sineOffset = Math.sin(t * sineFrequency) * sineAmplitude;

        // Random offset within band width
        const bandOffset = (Math.random() - 0.5) * bandWidth + sineOffset;

        // Final position
        const x = baseX + perpX * bandOffset;
        const y = baseY + perpY * bandOffset;

        // Check bounds and overlap (reduced padding for more density)
        const boundsInset = shapeConfig.distribution.boundsInset;
        if (x >= boundsInset && x <= paper.view.size.width - boundsInset &&
            y >= boundsInset && y <= paper.view.size.height - boundsInset &&
            !isTooClose(x, y, generatedShapes)) {

          // Equal distribution: cycle through shape types
          const type = shapeTypes[shapeCounter % shapeTypes.length];
          shapeCounter++;

          const sizeOptions = sizes[type as keyof typeof sizes];
          const size = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];

          // Equal distribution: cycle through colors
          const strokeColor = colorOptions[colorCounter % colorOptions.length];
          colorCounter++;

          // Equal distribution: cycle through stroke widths
          const strokeWidth = strokeWidthOptions[strokeCounter % strokeWidthOptions.length];
          strokeCounter++;

          // Random rotation
          const rotation = Math.random() * shapeConfig.appearance.initialRotation;

          // Add shape
          if (type === 'circle') {
            generatedShapes.push({
              type: 'circle',
              x, y,
              radius: size,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'rect') {
            generatedShapes.push({
              type: 'rect',
              x, y,
              width: size,
              height: size,
              radius: Math.random() > 0.5 ? 2.5 : 4.5,
              rotation,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'triangle') {
            generatedShapes.push({
              type: 'triangle',
              x, y,
              size,
              rotation,
              strokeColor,
              strokeWidth
            });
          }
        }
      }

      return generatedShapes;
    };

    const shapesData = generateShapesInDiagonalBand();

    // Draw visible sine wave band for debugging/visualization
    const drawSineWaveBand = () => {
      // Band parameters (must match generation parameters)
      const bandWidth = 300;
      const sineAmplitude = 100;
      const sineFrequency = 0.004;

      // Diagonal line from bottom-left to top-right
      const startPoint = { x: 0, y: paper.view.size.height };
      const endPoint = { x: paper.view.size.width, y: 0 };

      // Calculate diagonal distance
      const diagonalLength = Math.sqrt(
        Math.pow(endPoint.x - startPoint.x, 2) +
        Math.pow(endPoint.y - startPoint.y, 2)
      );

      // Unit vector along diagonal
      const directionX = (endPoint.x - startPoint.x) / diagonalLength;
      const directionY = (endPoint.y - startPoint.y) / diagonalLength;

      // Perpendicular vector (for band width)
      const perpX = -directionY;
      const perpY = directionX;

      // Draw center sine wave line
      const centerLine = new paper.Path();
      centerLine.strokeColor = new paper.Color('#FF0000');
      centerLine.strokeWidth = 2;
      centerLine.opacity = 0.3;
      centerLine.dashArray = [10, 5];

      // Draw upper boundary
      const upperBoundary = new paper.Path();
      upperBoundary.strokeColor = new paper.Color('#FFFFFF');
      upperBoundary.strokeWidth = 1;
      upperBoundary.opacity = 0.2;
      upperBoundary.dashArray = [5, 5];

      // Draw lower boundary
      const lowerBoundary = new paper.Path();
      lowerBoundary.strokeColor = new paper.Color('#FFFFFF');
      lowerBoundary.strokeWidth = 1;
      lowerBoundary.opacity = 0.2;
      lowerBoundary.dashArray = [5, 5];

      // Generate points along the diagonal
      for (let t = 0; t <= diagonalLength; t += 5) {
        // Position along the diagonal
        const baseX = startPoint.x + directionX * t;
        const baseY = startPoint.y + directionY * t;

        // Sine wave offset
        const sineOffset = Math.sin(t * sineFrequency) * sineAmplitude;

        // Center line point
        const centerX = baseX + perpX * sineOffset;
        const centerY = baseY + perpY * sineOffset;
        centerLine.add(new paper.Point(centerX, centerY));

        // Upper boundary point
        const upperOffset = sineOffset + bandWidth / 2;
        const upperX = baseX + perpX * upperOffset;
        const upperY = baseY + perpY * upperOffset;
        upperBoundary.add(new paper.Point(upperX, upperY));

        // Lower boundary point
        const lowerOffset = sineOffset - bandWidth / 2;
        const lowerX = baseX + perpX * lowerOffset;
        const lowerY = baseY + perpY * lowerOffset;
        lowerBoundary.add(new paper.Point(lowerX, lowerY));
      }

      // Return paths so they can be toggled later
      return { centerLine, upperBoundary, lowerBoundary };
    };

    // Draw the sine wave visualization
    const sineWaveGuides = drawSineWaveBand();

    // TOGGLE GUIDE VISIBILITY: Set to false to hide the sine wave guides
    const showGuides = true;
    if (!showGuides) {
      sineWaveGuides.centerLine.visible = false;
      sineWaveGuides.upperBoundary.visible = false;
      sineWaveGuides.lowerBoundary.visible = false;
    }

    // Create shapes
    const shapes: paper.Path[] = [];

    shapesData.forEach(shapeData => {
      let shape: paper.Path | paper.Shape;

      switch(shapeData.type) {
        case 'circle':
          shape = new paper.Path.Circle({
            center: [shapeData.x, shapeData.y],
            radius: shapeData.radius,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          break;

        case 'rect':
          shape = new paper.Path.Rectangle({
            point: [shapeData.x - shapeData.width/2, shapeData.y - shapeData.height/2],
            size: [shapeData.width, shapeData.height],
            radius: shapeData.radius || 0,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          // Set position to center after creation
          shape.position = new paper.Point(shapeData.x, shapeData.y);
          if (shapeData.rotation) {
            shape.rotate(shapeData.rotation, shape.position);
          }
          break;

        case 'triangle':
          shape = new paper.Path.RegularPolygon({
            center: [shapeData.x, shapeData.y],
            sides: 3,
            radius: shapeData.size,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          if (shapeData.rotation) {
            shape.rotate(shapeData.rotation);
          }
          // shape.smooth();
          shape.segments.forEach(segment => {
            segment.smooth();
          });
          break;

        case 'line':
          shape = new paper.Path.Line({
            from: [shapeData.x1, shapeData.y1],
            to: [shapeData.x2, shapeData.y2],
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
            strokeCap: 'round',
          });
          break;

        default:
          return;
      }

      // Add background fill to hide connection lines behind shapes
      // (except for line shapes which don't need fills)
      if (shapeData.type !== 'line') {
        shape.fillColor = new paper.Color(colors.background);
      }

      // Apply blur effect to some shapes randomly
      if (shapeConfig.blur.enabled && Math.random() < shapeConfig.blur.probability) {
        shape.shadowBlur = shapeConfig.blur.amount;
        shape.shadowColor = shape.strokeColor;
      }

      // Store original position and lifecycle data
      shape.data = {
        originalPosition: shape.position.clone(),
        originalRotation: shapeData.rotation || 0,
        floatPhaseY: Math.random() * Math.PI * 2, // Y-axis phase
        floatPhaseX: Math.random() * Math.PI * 2, // X-axis phase (different)
        rotationSpeed: shapeConfig.rotationSpeed.min + Math.random() * (shapeConfig.rotationSpeed.max - shapeConfig.rotationSpeed.min),
        floatSpeedY: shapeConfig.floatSpeed.yMin + Math.random() * (shapeConfig.floatSpeed.yMax - shapeConfig.floatSpeed.yMin),
        floatSpeedX: shapeConfig.floatSpeed.xMin + Math.random() * (shapeConfig.floatSpeed.xMax - shapeConfig.floatSpeed.xMin),
        amplitudeY: shapeConfig.amplitude.yMin + Math.random() * (shapeConfig.amplitude.yMax - shapeConfig.amplitude.yMin),
        amplitudeX: shapeConfig.amplitude.xMin + Math.random() * (shapeConfig.amplitude.xMax - shapeConfig.amplitude.xMin),
        // Lifecycle properties
        age: 0,
        lifespan: shapeConfig.lifespan.min + Math.random() * (shapeConfig.lifespan.max - shapeConfig.lifespan.min),
        baseX: shapeData.x, // Original X for respawn
        baseY: shapeData.y, // Original Y for respawn
        shapeType: shapeData.type,
        // Firing properties
        isFiring: false,
        fireIntensity: 0,
        fireDecay: shapeConfig.firing.decay,
        originalStrokeWidth: shapeData.strokeWidth,
        originalStrokeColor: shapeData.strokeColor,
        lastFireTime: connectionConfig.initialization.initialFireTime, // Last time this shape fired (frame number)
        fireCooldown: shapeConfig.firing.cooldown,
        lifespanExtension: shapeConfig.firing.lifespanExtension,
      };

      shapes.push(shape);
    });

    console.log(`Created ${shapes.length} shapes`);

    // Create neuron-like connections between nearby shapes
    const connections: any[] = [];

    const createConnections = () => {
      shapes.forEach((shape, i) => {
        shapes.forEach((otherShape, j) => {
          if (i >= j) return; // Avoid duplicate connections and self-connections

          const dx = otherShape.position.x - shape.position.x;
          const dy = otherShape.position.y - shape.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Only connect if within range and moving towards top-right direction
          // (target shape should be to the right and/or above)
          if (distance < connectionConfig.maxDistance &&
              (dx > 0 || dy < 0) && // Right or up
              Math.random() < connectionConfig.probability) {

            // Create line with gradient-like color effect
            const line = new paper.Path.Line({
              from: shape.position,
              to: otherShape.position,
              strokeColor: new paper.Color(colors.secondary), // Will be updated in animation loop
              strokeWidth: connectionConfig.staticStrokeWidth,
              opacity: connectionConfig.staticOpacity,
              dashArray: connectionConfig.staticDashArray,
            });

            // Store connection data
            line.data = {
              startShape: shape,
              endShape: otherShape,
              age: Math.random() * connectionConfig.initialization.maxAge, // Random starting age for staggered animation
              pulseSpeed: connectionConfig.pulseSpeed.min + Math.random() * (connectionConfig.pulseSpeed.max - connectionConfig.pulseSpeed.min),
              travelingPulses: [], // Array of pulses traveling along this connection
            };

            connections.push(line);
          }
        });
      });
    };

    createConnections();
    console.log(`Created ${connections.length} neuron connections`);

    // Send all connection lines to the back so shapes are drawn on top
    connections.forEach(connection => {
      connection.sendToBack();
    });

    // Regenerate connections for a specific shape
    const regenerateConnectionsForShape = (shape: paper.Path, index: number) => {
      // Create new connections FROM this shape to nearby shapes (outgoing)
      shapes.forEach((otherShape, j) => {
        if (index === j) return; // Skip self

        const dx = otherShape.position.x - shape.position.x;
        const dy = otherShape.position.y - shape.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Only connect if within range and moving towards top-right direction
        if (distance < connectionConfig.maxDistance &&
            (dx > 0 || dy < 0) && // Right or up
            Math.random() < connectionConfig.probability) {

          const line = new paper.Path.Line({
            from: shape.position,
            to: otherShape.position,
            strokeColor: new paper.Color(colors.secondary), // Will be updated in animation loop
            strokeWidth: connectionConfig.staticStrokeWidth,
            opacity: connectionConfig.staticOpacity,
            dashArray: connectionConfig.staticDashArray,
          });

          line.data = {
            startShape: shape,
            endShape: otherShape,
            age: Math.random() * connectionConfig.initialization.maxAge,
            pulseSpeed: connectionConfig.pulseSpeed.min + Math.random() * (connectionConfig.pulseSpeed.max - connectionConfig.pulseSpeed.min),
            travelingPulses: [],
          };

          line.sendToBack(); // Keep connection behind shapes
          connections.push(line);
        }
      });

      // Create new connections TO this shape from nearby shapes (incoming)
      shapes.forEach((otherShape, j) => {
        if (index === j) return; // Skip self

        const dx = shape.position.x - otherShape.position.x;
        const dy = shape.position.y - otherShape.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Only connect if within range and moving towards top-right direction
        if (distance < connectionConfig.maxDistance &&
            (dx > 0 || dy < 0) && // Right or up
            Math.random() < connectionConfig.probability) {

          const line = new paper.Path.Line({
            from: otherShape.position,
            to: shape.position,
            strokeColor: new paper.Color(colors.secondary), // Will be updated in animation loop
            strokeWidth: connectionConfig.staticStrokeWidth,
            opacity: connectionConfig.staticOpacity,
            dashArray: connectionConfig.staticDashArray,
          });

          line.data = {
            startShape: otherShape,
            endShape: shape,
            age: Math.random() * connectionConfig.initialization.maxAge,
            pulseSpeed: connectionConfig.pulseSpeed.min + Math.random() * (connectionConfig.pulseSpeed.max - connectionConfig.pulseSpeed.min),
            travelingPulses: [],
          };

          line.sendToBack(); // Keep connection behind shapes
          connections.push(line);
        }
      });
    };

    // Counters for equal distribution of shapes, colors, and stroke widths
    let shapeTypeCounter = 0;
    let colorCounter = 0;
    let strokeWidthCounter = 0;

    // Easing functions for smoother motion
    const easeInOutSine = (t: number) => -(Math.cos(Math.PI * t) - 1) / 2;
    const easeInOutQuad = (t: number) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    const easeInOutCubic = (t: number) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

    // Helper function to regenerate a shape with equal distribution
    const regenerateShape = (shape: paper.Path, index: number) => {
      const data = shape.data;
      const oldShape = shape; // Store reference to old shape before removal

      // Remove all connections that reference this old shape
      for (let i = connections.length - 1; i >= 0; i--) {
        const conn = connections[i];
        if (conn.data.startShape === oldShape || conn.data.endShape === oldShape) {
          // Clean up any traveling pulses
          conn.data.travelingPulses.forEach((pulse: any) => {
            if (pulse.segment) {
              pulse.segment.remove();
            }
          });
          conn.remove();
          connections.splice(i, 1);
        }
      }

      // Use exact original position (no jitter)
      const jitterX = (Math.random() - 0.5) * 2 * shapeConfig.regeneration.jitterX;
      const jitterY = (Math.random() - 0.5) * 2 * shapeConfig.regeneration.jitterY;
      const newX = data.baseX + jitterX;
      const newY = data.baseY + jitterY;

      // Equal distribution of shape types (cycle through)
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const newType = shapeTypes[shapeTypeCounter % shapeTypes.length];
      shapeTypeCounter++;

      // Equal distribution of sizes for each type
      const sizes = shapeConfig.sizes;
      const sizeOptions = sizes[newType as keyof typeof sizes];
      const sizeIndex = Math.floor(Math.random() * sizeOptions.length); // Keep size random within type
      const newSize = sizeOptions[sizeIndex] || shapeConfig.regeneration.defaultSizeFallback;

      // Equal distribution of colors (cycle through)
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const newColor = colorOptions[colorCounter % colorOptions.length];
      colorCounter++;

      // Equal distribution of stroke widths (cycle through)
      const strokeWidthOptions = shapeConfig.appearance.strokeWidthOptions;
      const newStrokeWidth = strokeWidthOptions[strokeWidthCounter % strokeWidthOptions.length];
      strokeWidthCounter++;

      // Random rotation
      const newRotation = Math.random() * shapeConfig.appearance.initialRotation;

      // Remove old shape
      shape.remove();

      // Create new shape
      let newShape: paper.Path | paper.Shape;

      switch(newType) {
        case 'circle':
          newShape = new paper.Path.Circle({
            center: [newX, newY],
            radius: newSize,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          break;

        case 'rect':
          newShape = new paper.Path.Rectangle({
            point: [newX - newSize/2, newY - newSize/2],
            size: [newSize, newSize],
            radius: Math.random() > 0.5 ? 2.5 : 4.5,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          newShape.position = new paper.Point(newX, newY);
          newShape.rotate(newRotation, newShape.position);
          break;

        case 'triangle':
          newShape = new paper.Path.RegularPolygon({
            center: [newX, newY],
            sides: 3,
            radius: newSize,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          newShape.rotate(newRotation);
          // newShape.smooth();
          newShape.segments.forEach(segment => {
          segment.smooth();
        });
          break;

        default:
          return;
      }

      // Add background fill to hide connection lines behind shapes
      newShape.fillColor = new paper.Color(colors.background);

      // Apply blur effect to some shapes randomly
      if (shapeConfig.blur.enabled && Math.random() < shapeConfig.blur.probability) {
        newShape.shadowBlur = shapeConfig.blur.amount;
        newShape.shadowColor = newShape.strokeColor;
      }

      // Reset lifecycle data with new randomized values
      newShape.data = {
        originalPosition: newShape.position.clone(),
        originalRotation: newRotation,
        floatPhaseY: Math.random() * Math.PI * 2,
        floatPhaseX: Math.random() * Math.PI * 2,
        rotationSpeed: shapeConfig.rotationSpeed.min + Math.random() * (shapeConfig.rotationSpeed.max - shapeConfig.rotationSpeed.min),
        floatSpeedY: shapeConfig.floatSpeed.yMin + Math.random() * (shapeConfig.floatSpeed.yMax - shapeConfig.floatSpeed.yMin),
        floatSpeedX: shapeConfig.floatSpeed.xMin + Math.random() * (shapeConfig.floatSpeed.xMax - shapeConfig.floatSpeed.xMin),
        amplitudeY: shapeConfig.amplitude.yMin + Math.random() * (shapeConfig.amplitude.yMax - shapeConfig.amplitude.yMin),
        amplitudeX: shapeConfig.amplitude.xMin + Math.random() * (shapeConfig.amplitude.xMax - shapeConfig.amplitude.xMin),
        age: 0,
        lifespan: shapeConfig.lifespan.min + Math.random() * (shapeConfig.lifespan.max - shapeConfig.lifespan.min),
        baseX: data.baseX, // Keep original base position
        baseY: data.baseY,
        shapeType: newType,
        // Firing properties
        isFiring: false,
        fireIntensity: 0,
        fireDecay: shapeConfig.firing.decay,
        originalStrokeWidth: newStrokeWidth,
        originalStrokeColor: newColor,
        lastFireTime: connectionConfig.initialization.initialFireTime,
        fireCooldown: shapeConfig.firing.cooldown,
        lifespanExtension: shapeConfig.firing.lifespanExtension,
      };

      // Replace in shapes array
      shapes[index] = newShape;

      // Regenerate connections for this new shape
      regenerateConnectionsForShape(newShape, index);
    };

    // Helper function to trigger a shape to fire
    const fireShape = (shape: paper.Path, currentFrame: number) => {
      // Safety check: ensure shape is still valid and in the shapes array
      if (!shape || !shape.data || !shapes.includes(shape)) {
        return;
      }

      // Check cooldown: prevent firing too frequently
      const timeSinceLastFire = currentFrame - shape.data.lastFireTime;
      if (timeSinceLastFire < shape.data.fireCooldown) {
        return; // Still in cooldown, don't fire
      }

      if (!shape.data.isFiring) {
        shape.data.isFiring = true;
        shape.data.fireIntensity = 1.0;
        shape.data.lastFireTime = currentFrame; // Update last fire time

        // Extend lifespan - active neurons live longer
        shape.data.lifespan += shape.data.lifespanExtension;

        // Send pulses along all outgoing connections
        connections.forEach((connection) => {
          if (connection.data.startShape === shape) {
            // Add a traveling pulse with random speed for organic variation
            const speedRange = connectionConfig.pulseSpeed.max - connectionConfig.pulseSpeed.min;
            connection.data.travelingPulses.push({
              progress: 0, // 0 = start, 1 = end
              speed: connectionConfig.pulseSpeed.min + Math.random() * speedRange,
              hasFired: false, // Track if target neuron has been fired
            });
          }
        });
      }
    };

    // Track current frame for mouse interaction
    let currentFrameCount = 0;

    // Organic floating animations - each shape moves independently in X and Y with easing
    paper.view.onFrame = (event: any) => {
      const time = event.count;
      currentFrameCount = time;

      // Randomly trigger fires from shapes (neural activity) - reduced frequency
      if (Math.random() < shapeConfig.fireEffects.randomFireProbability) {
        const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
        if (randomShape) {
          fireShape(randomShape, time);
        }
      }

      shapes.forEach((shape, index) => {
        // Regenerate before incrementing age if lifecycle is complete
        if (shape.data.age >= shape.data.lifespan) {
          regenerateShape(shape, index);
          // Get the newly regenerated shape
          const regeneratedShape = shapes[index];
          if (!regeneratedShape) return;
          shape = regeneratedShape;
        }

        // Increment age
        shape.data.age++;

        // Calculate fade in/out opacity based on lifecycle (linear)
        const fadeInDuration = shapeConfig.fade.fadeInDuration;
        const fadeOutDuration = shapeConfig.fade.fadeOutDuration;
        const age = shape.data.age;
        const lifespan = shape.data.lifespan;

        let opacity = 1;

        // Fade in at the beginning (linear)
        if (age <= fadeInDuration) {
          opacity = age / fadeInDuration;
        }
        // Fade out at the end (linear)
        else if (age >= lifespan - fadeOutDuration) {
          opacity = Math.max(0, (lifespan - age) / fadeOutDuration);
        }

        shape.opacity = opacity;

        // Handle firing state (glow effect)
        if (shape.data.isFiring) {
          shape.data.fireIntensity -= shape.data.fireDecay;
          if (shape.data.fireIntensity <= 0) {
            shape.data.isFiring = false;
            shape.data.fireIntensity = 0;
          }
        }

        // Apply glow effect when firing, or restore to normal
        if (shape.data.fireIntensity > 0) {
          // Increase stroke width to create glow
          shape.strokeWidth = shape.data.originalStrokeWidth + shape.data.fireIntensity * shapeConfig.fireEffects.glowStrokeMultiplier;

          // Brighten the color
          const glowColor = new paper.Color(shape.data.originalStrokeColor);
          glowColor.brightness += shape.data.fireIntensity * shapeConfig.fireEffects.glowBrightnessMultiplier;
          shape.strokeColor = glowColor;
        } else {
          // Restore to original appearance when not firing
          shape.strokeWidth = shape.data.originalStrokeWidth;
          shape.strokeColor = new paper.Color(shape.data.originalStrokeColor);
        }

        // Raw sine wave values (oscillating between -1 and 1)
        const rawSinY = Math.sin(time * shape.data.floatSpeedY + shape.data.floatPhaseY);
        const rawSinX = Math.sin(time * shape.data.floatSpeedX + shape.data.floatPhaseX);

        // Normalize to 0-1 range for easing function
        const normalizedY = (rawSinY + 1) / 2; // Convert -1..1 to 0..1
        const normalizedX = (rawSinX + 1) / 2;

        // Apply easing (creates smoother acceleration/deceleration)
        const easedY = easeInOutSine(normalizedY);
        const easedX = easeInOutSine(normalizedX);

        // Convert back to -1..1 range and apply amplitude
        const floatOffsetY = (easedY * 2 - 1) * shape.data.amplitudeY;
        const floatOffsetX = (easedX * 2 - 1) * shape.data.amplitudeX;

        // Apply both movements
        shape.position.x = shape.data.originalPosition.x + floatOffsetX;
        shape.position.y = shape.data.originalPosition.y + floatOffsetY;

        // Gentle rotation with easing
        const rotationEase = easeInOutSine(normalizedY);
        shape.rotate(shape.data.rotationSpeed * 60 * (rotationEase * 2 - 1));
      });

      // Animate neuron connections
      for (let i = connections.length - 1; i >= 0; i--) {
        const connection = connections[i];

        // Safety check: ensure both shapes are still valid
        const startShape = connection.data.startShape;
        const endShape = connection.data.endShape;

        if (!startShape || !endShape || !shapes.includes(startShape) || !shapes.includes(endShape)) {
          // Clean up invalid connection
          connection.data.travelingPulses.forEach((pulse: any) => {
            if (pulse.segment) pulse.segment.remove();
          });
          connection.remove();
          connections.splice(i, 1);
          continue;
        }

        // Update connection positions to follow shapes
        const startPos = startShape.position;
        const endPos = endShape.position;
        connection.segments[0].point = startPos;
        connection.segments[1].point = endPos;

        // Create gradient color from start node to end node
        const startNodeColor = new paper.Color(startShape.strokeColor);
        const endNodeColor = new paper.Color(endShape.strokeColor);

        // Create a linear gradient from start to end position
        const gradient = new paper.Color({
          gradient: {
            stops: [
              [startNodeColor, 0],
              [endNodeColor, 1]
            ]
          },
          origin: startPos,
          destination: endPos
        });

        connection.strokeColor = gradient;

        // Pulsing opacity animation (like neurons firing)
        connection.data.age += connection.data.pulseSpeed;
        const pulseValue = Math.sin(connection.data.age);
        connection.opacity = connectionConfig.pulseBaseOpacity +
          (pulseValue * connectionConfig.pulseVisuals.opacityMultiplier + connectionConfig.pulseVisuals.opacityOffset) * connectionConfig.pulseAmount;

        // Make connections fade with their connected shapes
        const startOpacity = connection.data.startShape.opacity;
        const endOpacity = connection.data.endShape.opacity;
        const minShapeOpacity = Math.min(startOpacity, endOpacity);
        connection.opacity *= minShapeOpacity;

        // Animate traveling pulses
        const pulses = connection.data.travelingPulses;
        for (let i = pulses.length - 1; i >= 0; i--) {
          const pulse = pulses[i];
          pulse.progress += pulse.speed;

          // Two-phase animation:
          // Phase 1: Line grows from A to B with easing
          // Phase 2: Line fades and shrinks from A side with easing
          const phase1Duration = connectionConfig.pulseGrowthPhase;
          const phase2Duration = connectionConfig.pulseFadePhase;

          let pulseStart = 0;
          let pulseEnd = 0;
          let opacity = 0.9;
          let strokeWidth = connectionConfig.pulseStrokeWidth.start;

          // Track if we've fired the target neuron yet
          if (!pulse.hasFired && pulse.progress >= phase1Duration) {
            // Fire the target neuron as soon as the pulse reaches it
            fireShape(connection.data.endShape, time);
            pulse.hasFired = true;
          }

          if (pulse.progress <= phase1Duration) {
            // Phase 1: Growing from A to B
            const t = pulse.progress / phase1Duration; // Normalize to 0-1
            const easedProgress = easeInOutCubic(t); // Apply easing

            pulseStart = 0;
            pulseEnd = easedProgress; // Grows from 0 to 1
            opacity = 0.9; // Full opacity during growth

            // Stroke width grows from start to peak
            strokeWidth = connectionConfig.pulseStrokeWidth.start +
              (connectionConfig.pulseStrokeWidth.peak - connectionConfig.pulseStrokeWidth.start) * easedProgress;
          } else {
            // Phase 2: Shrinking from start while fading
            const t = (pulse.progress - phase1Duration) / phase2Duration; // Normalize to 0-1
            const easedProgress = easeInOutCubic(t); // Apply easing

            pulseStart = easedProgress; // Shrinks from 0 to 1
            pulseEnd = 1; // Stays at end
            opacity = 0.9 * (1 - easedProgress); // Fade out as it shrinks

            // Stroke width shrinks from peak to end
            strokeWidth = connectionConfig.pulseStrokeWidth.peak +
              (connectionConfig.pulseStrokeWidth.end - connectionConfig.pulseStrokeWidth.peak) * easedProgress;
          }

          // Create gradient effect: interpolate color from start to end along the pulse
          const startColor = new paper.Color(startShape.strokeColor);
          const endColor = new paper.Color(endShape.strokeColor);

          // For gradient effect, we need to create a path with gradient stroke
          // Since Paper.js doesn't support gradient strokes directly, we'll use the average color
          // weighted by the pulse position for a smooth transition
          const averagePosition = (pulseStart + pulseEnd) / 2; // Midpoint of the pulse
          const pulseColor = startColor.clone();

          // Lerp between start and end color based on the pulse's average position
          pulseColor.red = startColor.red + (endColor.red - startColor.red) * averagePosition;
          pulseColor.green = startColor.green + (endColor.green - startColor.green) * averagePosition;
          pulseColor.blue = startColor.blue + (endColor.blue - startColor.blue) * averagePosition;

          if (!pulse.segment) {
            pulse.segment = new paper.Path.Line({
              from: startPos.add(endPos.subtract(startPos).multiply(pulseStart)),
              to: startPos.add(endPos.subtract(startPos).multiply(pulseEnd)),
              strokeColor: pulseColor,
              strokeWidth: strokeWidth,
              strokeCap: 'round',
            });

            // Apply blur effect to traveling pulse
            if (connectionConfig.pulseBlur.enabled) {
              pulse.segment.shadowBlur = connectionConfig.pulseBlur.amount;
              pulse.segment.shadowColor = pulseColor;
            }

            // Send pulse to back so it appears behind shapes
            pulse.segment.sendToBack();
          } else {
            // Update segment position, color, and stroke width
            pulse.segment.segments[0].point = startPos.add(endPos.subtract(startPos).multiply(pulseStart));
            pulse.segment.segments[1].point = startPos.add(endPos.subtract(startPos).multiply(pulseEnd));
            pulse.segment.strokeColor = pulseColor;
            pulse.segment.strokeWidth = strokeWidth;

            // Update shadow color to match pulse color
            if (connectionConfig.pulseBlur.enabled) {
              pulse.segment.shadowColor = pulseColor;
            }
          }

          // Apply the calculated opacity
          pulse.segment.opacity = opacity;

          // If pulse completed both phases, clean up
          if (pulse.progress >= 1) {
            if (pulse.segment) {
              pulse.segment.remove(); // Clean up the pulse segment
            }
            pulses.splice(i, 1); // Remove completed pulse
          }
        }
      }
    };

    console.log('Animation loop started');

    // Mouse interaction - fire nodes on hover
    let lastHoveredShape: paper.Path | null = null;

    paper.view.onMouseMove = (event: any) => {
      const hitResult = paper.project.hitTest(event.point, {
        fill: true,
        stroke: true,
        tolerance: 5
      });

      if (hitResult && hitResult.item) {
        // Check if the hit item is one of our shapes
        const hoveredShape = shapes.find(s => s === hitResult.item);

        if (hoveredShape && hoveredShape !== lastHoveredShape) {
          // Fire the shape when mouse enters it
          fireShape(hoveredShape, currentFrameCount);
          lastHoveredShape = hoveredShape;
        }
      } else {
        // Mouse is not over any shape
        lastHoveredShape = null;
      }
    };

    // Handle resize
    window.addEventListener('resize', () => {
      paper.view.viewSize = new paper.Size(window.innerWidth, window.innerHeight);
    });
  }

  // Run when DOM is ready
  console.log('Script loaded! readyState:', document.readyState);

  if (document.readyState === 'loading') {
    console.log('Waiting for DOMContentLoaded...');
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded fired!');
      initPaperCanvas();
    });
  } else {
    console.log('DOM already ready, initializing immediately');
    initPaperCanvas();
  }
</script>