---
/**
 * PaperCanvasExact Component
 *
 * Paper.js canvas with exact shapes from bg.svg design
 * All positions, colors, and sizes match the original Figma design
 */
---

<div id="geometric-canvas-container" class="paper-canvas-container">
  <canvas id="geometric-canvas" resize></canvas>
</div>

<style>
  .paper-canvas-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
  }

  #geometric-canvas {
    width: 100%;
    height: 100%;
    pointer-events: auto;
  }
</style>

<script>
  import paper from 'paper';

  // Initialize Paper.js - run immediately since Astro scripts are deferred by default
  function initPaperCanvas() {
    const canvas = document.getElementById('geometric-canvas') as HTMLCanvasElement;
    if (!canvas) {
      console.error('Canvas not found!');
      return;
    }

    console.log('Initializing Paper.js...');

    // Setup Paper.js
    paper.setup(canvas);

    console.log('Paper.js setup complete');

    // Helper function to get CSS variable value
    const getCSSVariable = (variableName: string): string => {
      return getComputedStyle(document.documentElement)
        .getPropertyValue(variableName)
        .trim();
    };

    // Colors - using your Figma Design System from BaseLayout.astro
    const colors = {
      primary: getCSSVariable('--color-primary') || '#0A3A52',              // Darkest Blue - Primary BG
      primaryLight: getCSSVariable('--color-primary-light') || '#004B72',   // Dark Blue
      secondary: getCSSVariable('--color-secondary') || '#006BA5',          // Medium Blue - Interactive
      secondaryLight: getCSSVariable('--color-secondary-light') || '#3E9FD4', // Cyan - Highlights & Titles
      tertiary: getCSSVariable('--color-secondary') || '#006BA5',           // Alias for secondary (backward compatibility)
      accent: getCSSVariable('--color-accent') || '#F0000F',                // Primary Red - CTA
      accentDark: getCSSVariable('--color-accent-dark') || '#BF0B16',       // Dark Red
      lineAccent: getCSSVariable('--color-line-accent') || '#E00514',       // Line accents
      white: getCSSVariable('--color-white') || '#FFFFFF',
      background: getCSSVariable('--color-primary') || '#0A3A52',           // Use primary color as background (matches page bg)
    };

    // Configuration presets for different sections
    const configPresets = {
      home: {
        pattern: 'diagonal',  // Diagonal sine wave pattern
        sizes: { circle: [14, 18, 12], rect: [15, 22, 18], triangle: [17, 14, 20] },
        distribution: {
          minDistance: 50,
          bandWidth: 300,
          sineAmplitude: 100,
          sineFrequency: 0.004,
          spacing: 5,
          spacingRandomness: 3,
          edgeMargin: 50,
          boundsInset: 30,
        },
        appearance: { strokeWidthOptions: [2, 3, 5] },
      },
      skills: {
        pattern: 'curve',  // Bezier curve using control points
        sizes: { circle: [1], rect: [1], triangle: [1] },
        distribution: {
          minDistance: 10,
          bandWidth: 300,     // Width of curve band
          spacing: 20,
          spacingRandomness: 3,
          edgeMargin: 10,
          boundsInset: 30,
          // Control points for smooth arc (as fractions of screen: 0-1)
          // Arc from bottom-right to top-right with gentle leftward curve
          // curveControlPoints: [
          //   { x: 0.85, y: 1.0 },   // Start: bottom-right
          //   { x: 0.65, y: 0.75 },  // Control: pull left in middle-lower
          //   { x: 0.70, y: 0.25 },  // Control: slight left in middle-upper
          //   { x: 0.85, y: 0.0 }    // End: top-right
          // ]
          curveControlPoints: [
            { x: 0.95, y: 1.0 },   // Start: bottom-right
            { x: 0.75, y: 0.55 },  // Control: pull left in middle-lower
            { x: 0.70, y: 0.25 },  // Control: slight left in middle-upper
            { x: 0, y: 0 }    // End: top-right
          ]
        },
        appearance: { strokeWidthOptions: [2, 3, 4] },
      },
      experience: {
        pattern: 'circle',    // Large circular arrangement touching bottom
        sizes: { circle: [7, 8, 6], rect: [7, 9, 8], triangle: [8, 7, 9] },
        distribution: {
          minDistance: 50,
          bandWidth: 200,     // Wide band for space in center
          sineAmplitude: 0,
          sineFrequency: 0,
          spacing: 5,
          spacingRandomness: 3,
          edgeMargin: 50,
          boundsInset: 30,
          circleRadius: 600,  // Large radius
          circleOffsetY: 500, // Offset down so circle touches bottom
        },
        appearance: { strokeWidthOptions: [2, 3, 5] },
      },
    };

    // Current active config (starts with home)
    let currentPresetName = 'home';
    let targetPresetName = 'home';
    let transitionProgress = 1; // 0-1, where 1 means fully transitioned

    // Build dynamic shapeConfig from preset
    const buildShapeConfig = (preset: typeof configPresets.home) => ({
      rotationSpeed: { min: -0.005, max: 0.005 },
      floatSpeed: { yMin: 0.01, yMax: 0.03, xMin: 0.0, xMax: 0.0 },
      amplitude: { yMin: 1, yMax: 4, xMin: 1, xMax: 1.03 },
      blur: { enabled: false, probability: 0.3, amount: 8 },
      lifespan: { min: 2, max: 50 },
      firing: { decay: 0.08, cooldown: 180, lifespanExtension: 100 },
      sizes: preset.sizes,
      distribution: preset.distribution,
      appearance: { ...preset.appearance, initialRotation: 360 },
      fade: { fadeInDuration: 10, fadeOutDuration: 10 },
      fireEffects: { randomFireProbability: 0.003, glowStrokeMultiplier: 3, glowBrightnessMultiplier: 0.3 },
      regeneration: { jitterX: 0, jitterY: 0, defaultSizeFallback: 20 },
    });

    // Initialize with home preset
    let shapeConfig = buildShapeConfig(configPresets.home);

    // Connection line configuration - adjust all connection properties here
    const connectionConfig = {
      // Connection creation
      maxDistance: 150,          // Maximum distance to connect shapes
      probability: 0.5,          // Probability of creating a connection (0-1)

      // Static connection line appearance
      staticOpacity: 0.4,        // Base opacity of connection lines (0-1)
      staticStrokeWidth: .5,     // Line thickness
      staticDashArray: [2, 4],    // Dash pattern [dash, gap]

      // Pulsing animation for connection lines
      pulseBaseOpacity: 0.7,     // Minimum opacity during pulse
      pulseAmount: 0.3,           // How much the pulse adds to opacity

      // Traveling pulse animation
      pulseSpeed: {
        min: 0.05,               // Minimum pulse travel speed (slower)
        max: 0.3,                // Maximum pulse travel speed (faster)
      },

      // Traveling pulse stroke width animation
      pulseStrokeWidth: {
        start: 0.05,               // Starting width (thin)
        peak: 3,                  // Peak width (thick)
        end: .05,                   // Ending width (medium)
      },

      // Pulse blur effect
      pulseBlur: {
        enabled: false,            // Enable blur on traveling pulses
        amount: 10,               // Blur radius in pixels
      },

      // Phase durations for pulse animation
      pulseGrowthPhase: 0.3,      // Duration of growth phase (0-1)
      pulseFadePhase: 0.7,        // Duration of fade/shrink phase (0-1)

      // Pulse visual effects
      pulseVisuals: {
        opacityMultiplier: 0.5,   // How much base pulse opacity affects final value (0-1)
        opacityOffset: 0.5,       // Offset added to pulse opacity calculation (0-1)
      },

      // Connection data initialization
      initialization: {
        maxAge: 60,               // Maximum initial age for staggered animation
        initialFireTime: -300,   // Initial lastFireTime value (frame number)
      },
    };

    // ==================== BEZIER CURVE FUNCTIONS ====================

    // Cubic Bezier curve function: B(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3
    const bezierPoint = (t: number, p0: {x: number, y: number}, p1: {x: number, y: number},
                         p2: {x: number, y: number}, p3: {x: number, y: number}) => {
      const mt = 1 - t;
      const mt2 = mt * mt;
      const mt3 = mt2 * mt;
      const t2 = t * t;
      const t3 = t2 * t;

      return {
        x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,
        y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y
      };
    };

    // Calculate tangent (derivative) of Bezier curve at parameter t
    const bezierTangent = (t: number, p0: {x: number, y: number}, p1: {x: number, y: number},
                           p2: {x: number, y: number}, p3: {x: number, y: number}) => {
      const mt = 1 - t;
      const mt2 = mt * mt;
      const t2 = t * t;

      const dx = -3 * mt2 * p0.x + 3 * mt2 * p1.x - 6 * mt * t * p1.x + 6 * mt * t * p2.x - 3 * t2 * p2.x + 3 * t2 * p3.x;
      const dy = -3 * mt2 * p0.y + 3 * mt2 * p1.y - 6 * mt * t * p1.y + 6 * mt * t * p2.y - 3 * t2 * p2.y + 3 * t2 * p3.y;

      return { dx, dy };
    };

    // Get perpendicular direction (normalized) at a point on the Bezier curve
    const bezierPerpendicular = (t: number, p0: {x: number, y: number}, p1: {x: number, y: number},
                                 p2: {x: number, y: number}, p3: {x: number, y: number}) => {
      const tangent = bezierTangent(t, p0, p1, p2, p3);

      // Perpendicular is (-dy, dx) rotated 90° counter-clockwise
      const perpX = -tangent.dy;
      const perpY = tangent.dx;

      // Normalize
      const length = Math.sqrt(perpX * perpX + perpY * perpY);
      return {
        x: perpX / length,
        y: perpY / length
      };
    };

    // ==================== SHAPE GENERATION FUNCTIONS ====================

    // Generate shapes within a diagonal sine wave band (bottom-left to top-right)
    const generateShapesInDiagonalBand = () => {
      const generatedShapes: any[] = [];
      // Shape distribution parameters from config
      const minDistance = shapeConfig.distribution.minDistance;
      const bandWidth = shapeConfig.distribution.bandWidth;
      const sineAmplitude = shapeConfig.distribution.sineAmplitude;
      const sineFrequency = shapeConfig.distribution.sineFrequency;

      // Diagonal line from bottom-left to top-right
      const startPoint = { x: 0, y: paper.view.size.height };
      const endPoint = { x: paper.view.size.width, y: 0 };

      // Calculate diagonal distance
      const diagonalLength = Math.sqrt(
        Math.pow(endPoint.x - startPoint.x, 2) +
        Math.pow(endPoint.y - startPoint.y, 2)
      );

      // Unit vector along diagonal
      const directionX = (endPoint.x - startPoint.x) / diagonalLength;
      const directionY = (endPoint.y - startPoint.y) / diagonalLength;

      // Perpendicular vector (for band width)
      const perpX = -directionY;
      const perpY = directionX;

      // Shape types to cycle through for equal distribution
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const sizes = shapeConfig.sizes;
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const strokeWidthOptions = shapeConfig.appearance.strokeWidthOptions;

      // Counters for equal distribution
      let shapeCounter = 0;
      let colorCounter = 0;
      let strokeCounter = 0;

      // Check if position is too close to existing shapes
      const isTooClose = (x: number, y: number, existing: any[]) => {
        return existing.some(shape => {
          const dx = shape.x - x;
          const dy = shape.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });
      };

      // Generate shapes along the diagonal band
      const spacing = shapeConfig.distribution.spacing;
      const edgeMargin = shapeConfig.distribution.edgeMargin;
      const spacingRandomness = shapeConfig.distribution.spacingRandomness;

      for (let t = edgeMargin; t < diagonalLength - edgeMargin; t += spacing + Math.random() * spacingRandomness) {
        // Position along the diagonal
        const baseX = startPoint.x + directionX * t;
        const baseY = startPoint.y + directionY * t;

        // Sine wave offset (oscillates perpendicular to diagonal)
        const sineOffset = Math.sin(t * sineFrequency) * sineAmplitude;

        // Random offset within band width
        const bandOffset = (Math.random() - 0.5) * bandWidth + sineOffset;

        // Final position
        const x = baseX + perpX * bandOffset;
        const y = baseY + perpY * bandOffset;

        // Check bounds and overlap (reduced padding for more density)
        const boundsInset = shapeConfig.distribution.boundsInset;
        if (x >= boundsInset && x <= paper.view.size.width - boundsInset &&
            y >= boundsInset && y <= paper.view.size.height - boundsInset &&
            !isTooClose(x, y, generatedShapes)) {

          // Equal distribution: cycle through shape types
          const type = shapeTypes[shapeCounter % shapeTypes.length];
          shapeCounter++;

          const sizeOptions = sizes[type as keyof typeof sizes];
          const size = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];

          // Equal distribution: cycle through colors
          const strokeColor = colorOptions[colorCounter % colorOptions.length];
          colorCounter++;

          // Equal distribution: cycle through stroke widths
          const strokeWidth = strokeWidthOptions[strokeCounter % strokeWidthOptions.length];
          strokeCounter++;

          // Random rotation
          const rotation = Math.random() * shapeConfig.appearance.initialRotation;

          // Add shape
          if (type === 'circle') {
            generatedShapes.push({
              type: 'circle',
              x, y,
              radius: size,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'rect') {
            generatedShapes.push({
              type: 'rect',
              x, y,
              width: size,
              height: size,
              radius: Math.random() > 0.5 ? 2.5 : 4.5,
              rotation,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'triangle') {
            generatedShapes.push({
              type: 'triangle',
              x, y,
              size,
              rotation,
              strokeColor,
              strokeWidth
            });
          }
        }
      }

      return generatedShapes;
    };

    // Generate shapes in a vertical line from bottom to top (centered)
    const generateShapesInVerticalLine = () => {
      const generatedShapes: any[] = [];
      const minDistance = shapeConfig.distribution.minDistance;
      const bandWidth = shapeConfig.distribution.bandWidth;

      // Get positioning parameters (with defaults)
      const horizontalPosition = (shapeConfig.distribution as any).horizontalPosition || 0.5;
      const angleDegrees = (shapeConfig.distribution as any).angle || 0;

      // Convert angle to radians
      const angleRadians = (angleDegrees * Math.PI) / 180;

      // Calculate base X position
      const baseX = paper.view.size.width * horizontalPosition;

      // Calculate horizontal offset based on angle
      const height = paper.view.size.height;
      const horizontalOffset = Math.tan(angleRadians) * height;

      // Calculate the actual line direction vector (from bottom to top)
      const lineDirX = horizontalOffset;
      const lineDirY = -height;

      // Calculate perpendicular vector (rotate 90° counter-clockwise)
      const perpDirX = -lineDirY; // = height
      const perpDirY = lineDirX; // = horizontalOffset

      // Normalize the perpendicular vector
      const perpLength = Math.sqrt(perpDirX * perpDirX + perpDirY * perpDirY);
      const perpX = perpDirX / perpLength;
      const perpY = perpDirY / perpLength;

      // Shape types for equal distribution
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const sizes = shapeConfig.sizes;
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const strokeWidthOptions = shapeConfig.appearance.strokeWidthOptions;

      // Counters for equal distribution
      let shapeCounter = 0;
      let colorCounter = 0;
      let strokeCounter = 0;

      // Check if position is too close to existing shapes
      const isTooClose = (x: number, y: number, existing: any[]) => {
        return existing.some(shape => {
          const dx = shape.x - x;
          const dy = shape.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });
      };

      // Generate shapes along angled line from bottom to top
      const spacing = shapeConfig.distribution.spacing;
      const edgeMargin = shapeConfig.distribution.edgeMargin;
      const spacingRandomness = shapeConfig.distribution.spacingRandomness;
      const boundsInset = shapeConfig.distribution.boundsInset;

      for (let y = edgeMargin; y < height - edgeMargin; y += spacing + Math.random() * spacingRandomness) {
        // Progress along the line (0 at bottom, 1 at top)
        const progress = y / height;

        // X position along the angled line
        const lineX = baseX + horizontalOffset * (0.5 - progress);

        // Random offset within band width (perpendicular to the line)
        const bandOffset = (Math.random() - 0.5) * bandWidth;
        const x = lineX + perpX * bandOffset;
        const yAdjusted = y + perpY * bandOffset;

        // Check bounds and overlap
        if (x >= boundsInset && x <= paper.view.size.width - boundsInset &&
            yAdjusted >= boundsInset && yAdjusted <= height - boundsInset &&
            !isTooClose(x, yAdjusted, generatedShapes)) {

          // Equal distribution: cycle through shape types
          const type = shapeTypes[shapeCounter % shapeTypes.length];
          shapeCounter++;

          const sizeOptions = sizes[type as keyof typeof sizes];
          const size = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];

          // Equal distribution: cycle through colors
          const strokeColor = colorOptions[colorCounter % colorOptions.length];
          colorCounter++;

          // Equal distribution: cycle through stroke widths
          const strokeWidth = strokeWidthOptions[strokeCounter % strokeWidthOptions.length];
          strokeCounter++;

          // Random rotation
          const rotation = Math.random() * shapeConfig.appearance.initialRotation;

          // Add shape
          if (type === 'circle') {
            generatedShapes.push({
              type: 'circle',
              x, y: yAdjusted,
              radius: size,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'rect') {
            generatedShapes.push({
              type: 'rect',
              x, y: yAdjusted,
              width: size,
              height: size,
              radius: Math.random() > 0.5 ? 2.5 : 4.5,
              rotation,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'triangle') {
            generatedShapes.push({
              type: 'triangle',
              x, y: yAdjusted,
              size,
              rotation,
              strokeColor,
              strokeWidth
            });
          }
        }
      }

      return generatedShapes;
    };

    // Generate shapes in a circular pattern
    const generateShapesInCircle = () => {
      const generatedShapes: any[] = [];
      const minDistance = shapeConfig.distribution.minDistance;
      const bandWidth = shapeConfig.distribution.bandWidth;
      const circleRadius = (shapeConfig.distribution as any).circleRadius || 500;
      const circleOffsetY = (shapeConfig.distribution as any).circleOffsetY || 0;

      // Center of the circle (offset vertically to touch bottom)
      const centerX = paper.view.size.width / 2;
      const centerY = paper.view.size.height - circleRadius + circleOffsetY;

      // Shape types for equal distribution
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const sizes = shapeConfig.sizes;
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const strokeWidthOptions = shapeConfig.appearance.strokeWidthOptions;

      // Counters for equal distribution
      let shapeCounter = 0;
      let colorCounter = 0;
      let strokeCounter = 0;

      // Check if position is too close to existing shapes
      const isTooClose = (x: number, y: number, existing: any[]) => {
        return existing.some(shape => {
          const dx = shape.x - x;
          const dy = shape.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });
      };

      // Generate shapes around the circle
      const spacing = shapeConfig.distribution.spacing;
      const spacingRandomness = shapeConfig.distribution.spacingRandomness;
      const boundsInset = shapeConfig.distribution.boundsInset;

      // Calculate angle step for shape distribution around circle
      const angleStep = (spacing + Math.random() * spacingRandomness) / circleRadius;

      for (let angle = 0; angle < Math.PI * 2; angle += angleStep) {
        // Random radial offset within band width
        const radialOffset = (Math.random() - 0.5) * bandWidth;
        const r = circleRadius + radialOffset;

        // Calculate position on circle
        const x = centerX + r * Math.cos(angle);
        const y = centerY + r * Math.sin(angle);

        // Check bounds and overlap
        if (x >= boundsInset && x <= paper.view.size.width - boundsInset &&
            y >= boundsInset && y <= paper.view.size.height - boundsInset &&
            !isTooClose(x, y, generatedShapes)) {

          // Equal distribution: cycle through shape types
          const type = shapeTypes[shapeCounter % shapeTypes.length];
          shapeCounter++;

          const sizeOptions = sizes[type as keyof typeof sizes];
          const size = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];

          // Equal distribution: cycle through colors
          const strokeColor = colorOptions[colorCounter % colorOptions.length];
          colorCounter++;

          // Equal distribution: cycle through stroke widths
          const strokeWidth = strokeWidthOptions[strokeCounter % strokeWidthOptions.length];
          strokeCounter++;

          // Random rotation
          const rotation = Math.random() * shapeConfig.appearance.initialRotation;

          // Add shape
          if (type === 'circle') {
            generatedShapes.push({
              type: 'circle',
              x, y,
              radius: size,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'rect') {
            generatedShapes.push({
              type: 'rect',
              x, y,
              width: size,
              height: size,
              radius: Math.random() > 0.5 ? 2.5 : 4.5,
              rotation,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'triangle') {
            generatedShapes.push({
              type: 'triangle',
              x, y,
              size,
              rotation,
              strokeColor,
              strokeWidth
            });
          }
        }
      }

      return generatedShapes;
    };

    // Generate shapes along a Bezier curve
    const generateShapesAlongCurve = () => {
      const generatedShapes: any[] = [];
      const minDistance = shapeConfig.distribution.minDistance;
      const bandWidth = shapeConfig.distribution.bandWidth;

      // Get control points from config (as screen fractions 0-1)
      const controlPoints = (shapeConfig.distribution as any).curveControlPoints;
      if (!controlPoints || controlPoints.length !== 4) {
        console.error('Curve pattern requires exactly 4 control points');
        return [];
      }

      // Convert control points to pixel coordinates
      const p0 = { x: controlPoints[0].x * paper.view.size.width, y: controlPoints[0].y * paper.view.size.height };
      const p1 = { x: controlPoints[1].x * paper.view.size.width, y: controlPoints[1].y * paper.view.size.height };
      const p2 = { x: controlPoints[2].x * paper.view.size.width, y: controlPoints[2].y * paper.view.size.height };
      const p3 = { x: controlPoints[3].x * paper.view.size.width, y: controlPoints[3].y * paper.view.size.height };

      // Shape types for equal distribution
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const sizes = shapeConfig.sizes;
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const strokeWidthOptions = shapeConfig.appearance.strokeWidthOptions;

      // Counters for equal distribution
      let shapeCounter = 0;
      let colorCounter = 0;
      let strokeCounter = 0;

      // Check if position is too close to existing shapes
      const isTooClose = (x: number, y: number, existing: any[]) => {
        return existing.some(shape => {
          const dx = shape.x - x;
          const dy = shape.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });
      };

      // Generate shapes along the curve
      const spacing = shapeConfig.distribution.spacing;
      const spacingRandomness = shapeConfig.distribution.spacingRandomness;
      const boundsInset = shapeConfig.distribution.boundsInset;

      // Sample points along the curve (t from 0 to 1)
      for (let t = 0; t <= 1; t += 0.01) { // Sample every 1% along curve
        // Get point on curve
        const curvePoint = bezierPoint(t, p0, p1, p2, p3);

        // Get perpendicular direction
        const tangent = bezierTangent(t, p0, p1, p2, p3);
        const perpX = -tangent.dy;
        const perpY = tangent.dx;
        const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        const perpNormX = perpX / perpLength;
        const perpNormY = perpY / perpLength;

        // Random offset within band width (perpendicular to curve)
        const bandOffset = (Math.random() - 0.5) * bandWidth;
        const x = curvePoint.x + perpNormX * bandOffset;
        const y = curvePoint.y + perpNormY * bandOffset;

        // Check bounds and overlap
        if (x >= boundsInset && x <= paper.view.size.width - boundsInset &&
            y >= boundsInset && y <= paper.view.size.height - boundsInset &&
            !isTooClose(x, y, generatedShapes)) {

          // Random spacing check
          if (Math.random() < spacing / 100) {
            // Equal distribution: cycle through shape types
            const type = shapeTypes[shapeCounter % shapeTypes.length];
            shapeCounter++;

            const sizeOptions = sizes[type as keyof typeof sizes];
            const size = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];

            // Equal distribution: cycle through colors
            const strokeColor = colorOptions[colorCounter % colorOptions.length];
            colorCounter++;

            // Equal distribution: cycle through stroke widths
            const strokeWidth = strokeWidthOptions[strokeCounter % strokeWidthOptions.length];
            strokeCounter++;

            // Random rotation
            const rotation = Math.random() * shapeConfig.appearance.initialRotation;

            // Add shape
            if (type === 'circle') {
              generatedShapes.push({
                type: 'circle',
                x, y,
                radius: size,
                strokeColor,
                strokeWidth
              });
            } else if (type === 'rect') {
              generatedShapes.push({
                type: 'rect',
                x, y,
                width: size,
                height: size,
                radius: Math.random() > 0.5 ? 2.5 : 4.5,
                rotation,
                strokeColor,
                strokeWidth
              });
            } else if (type === 'triangle') {
              generatedShapes.push({
                type: 'triangle',
                x, y,
                size,
                rotation,
                strokeColor,
                strokeWidth
              });
            }
          }
        }
      }

      return generatedShapes;
    };

    // Generate shapes based on current pattern
    const generateShapes = () => {
      const currentPreset = configPresets[currentPresetName as keyof typeof configPresets];
      const pattern = currentPreset.pattern;

      if (pattern === 'curve') {
        return generateShapesAlongCurve();
      } else if (pattern === 'vertical') {
        return generateShapesInVerticalLine();
      } else if (pattern === 'circle') {
        return generateShapesInCircle();
      } else {
        return generateShapesInDiagonalBand();
      }
    };

    // Generate a single shape position based on current pattern (for morphing)
    const generateSingleShapePosition = (existingShapes: any[]) => {
      const currentPreset = configPresets[currentPresetName as keyof typeof configPresets];
      const pattern = currentPreset.pattern;
      const minDistance = shapeConfig.distribution.minDistance;
      const boundsInset = shapeConfig.distribution.boundsInset;

      // Check if position is too close to existing shapes
      const isTooClose = (x: number, y: number) => {
        return existingShapes.some(shape => {
          const dx = shape.position.x - x;
          const dy = shape.position.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });
      };

      let attempts = 0;
      const maxAttempts = 100;

      while (attempts < maxAttempts) {
        let x: number, y: number;

        if (pattern === 'curve') {
          // Bezier curve pattern
          const bandWidth = shapeConfig.distribution.bandWidth;
          const controlPoints = (shapeConfig.distribution as any).curveControlPoints;

          if (!controlPoints || controlPoints.length !== 4) {
            // Fallback to center if no control points
            x = paper.view.size.width * 0.5;
            y = paper.view.size.height * 0.5;
          } else {
            // Convert control points to pixel coordinates
            const p0 = { x: controlPoints[0].x * paper.view.size.width, y: controlPoints[0].y * paper.view.size.height };
            const p1 = { x: controlPoints[1].x * paper.view.size.width, y: controlPoints[1].y * paper.view.size.height };
            const p2 = { x: controlPoints[2].x * paper.view.size.width, y: controlPoints[2].y * paper.view.size.height };
            const p3 = { x: controlPoints[3].x * paper.view.size.width, y: controlPoints[3].y * paper.view.size.height };

            // Random point along curve (t from 0 to 1)
            const t = Math.random();
            const curvePoint = bezierPoint(t, p0, p1, p2, p3);

            // Get perpendicular direction
            const tangent = bezierTangent(t, p0, p1, p2, p3);
            const perpX = -tangent.dy;
            const perpY = tangent.dx;
            const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
            const perpNormX = perpX / perpLength;
            const perpNormY = perpY / perpLength;

            // Random offset within band width
            const bandOffset = (Math.random() - 0.5) * bandWidth;
            x = curvePoint.x + perpNormX * bandOffset;
            y = curvePoint.y + perpNormY * bandOffset;
          }

        } else if (pattern === 'vertical') {
          // Vertical line pattern with positioning and angle
          const horizontalPosition = (shapeConfig.distribution as any).horizontalPosition || 0.5;
          const angleDegrees = (shapeConfig.distribution as any).angle || 0;
          const bandWidth = shapeConfig.distribution.bandWidth;
          const edgeMargin = shapeConfig.distribution.edgeMargin;

          // Convert angle to radians
          const angleRadians = (angleDegrees * Math.PI) / 180;
          const baseX = paper.view.size.width * horizontalPosition;
          const height = paper.view.size.height;
          const horizontalOffset = Math.tan(angleRadians) * height;

          // Calculate the actual line direction vector and perpendicular
          const lineDirX = horizontalOffset;
          const lineDirY = -height;
          const perpDirX = -lineDirY; // = height
          const perpDirY = lineDirX; // = horizontalOffset
          const perpLength = Math.sqrt(perpDirX * perpDirX + perpDirY * perpDirY);
          const perpX = perpDirX / perpLength;
          const perpY = perpDirY / perpLength;

          y = edgeMargin + Math.random() * (height - 2 * edgeMargin);
          const progress = y / height;
          const lineX = baseX + horizontalOffset * (0.5 - progress);

          // Random offset within band width (perpendicular to line)
          const bandOffset = (Math.random() - 0.5) * bandWidth;
          x = lineX + perpX * bandOffset;
          y = y + perpY * bandOffset;

        } else if (pattern === 'circle') {
          // Circular pattern (touching bottom)
          const circleRadius = (shapeConfig.distribution as any).circleRadius || 500;
          const circleOffsetY = (shapeConfig.distribution as any).circleOffsetY || 0;
          const bandWidth = shapeConfig.distribution.bandWidth;
          const centerX = paper.view.size.width / 2;
          const centerY = paper.view.size.height - circleRadius + circleOffsetY;

          const angle = Math.random() * Math.PI * 2;
          const radialOffset = (Math.random() - 0.5) * bandWidth;
          const r = circleRadius + radialOffset;

          x = centerX + r * Math.cos(angle);
          y = centerY + r * Math.sin(angle);

        } else {
          // Diagonal pattern
          const bandWidth = shapeConfig.distribution.bandWidth;
          const sineAmplitude = shapeConfig.distribution.sineAmplitude;
          const sineFrequency = shapeConfig.distribution.sineFrequency;
          const edgeMargin = shapeConfig.distribution.edgeMargin;

          const startPoint = { x: 0, y: paper.view.size.height };
          const endPoint = { x: paper.view.size.width, y: 0 };
          const diagonalLength = Math.sqrt(
            Math.pow(endPoint.x - startPoint.x, 2) +
            Math.pow(endPoint.y - startPoint.y, 2)
          );

          const directionX = (endPoint.x - startPoint.x) / diagonalLength;
          const directionY = (endPoint.y - startPoint.y) / diagonalLength;
          const perpX = -directionY;
          const perpY = directionX;

          const t = edgeMargin + Math.random() * (diagonalLength - 2 * edgeMargin);
          const baseX = startPoint.x + directionX * t;
          const baseY = startPoint.y + directionY * t;
          const sineOffset = Math.sin(t * sineFrequency) * sineAmplitude;
          const bandOffset = (Math.random() - 0.5) * bandWidth + sineOffset;

          x = baseX + perpX * bandOffset;
          y = baseY + perpY * bandOffset;
        }

        // Check bounds and overlap
        if (x >= boundsInset && x <= paper.view.size.width - boundsInset &&
            y >= boundsInset && y <= paper.view.size.height - boundsInset &&
            !isTooClose(x, y)) {
          return { x, y };
        }

        attempts++;
      }

      // If we couldn't find a good spot, return a random position in the center
      return {
        x: paper.view.size.width * (0.3 + Math.random() * 0.4),
        y: paper.view.size.height * (0.3 + Math.random() * 0.4)
      };
    };

    const shapesData = generateShapes();

    // Dynamic guide drawing functions for all patterns
    const drawDiagonalGuides = (centerLine: paper.Path, upperBoundary: paper.Path, lowerBoundary: paper.Path) => {
      // Get current preset config
      const preset = configPresets[targetPresetName as keyof typeof configPresets];
      const bandWidth = preset.distribution.bandWidth;
      const sineAmplitude = preset.distribution.sineAmplitude;
      const sineFrequency = preset.distribution.sineFrequency;

      // Diagonal line from bottom-left to top-right
      const startPoint = { x: 0, y: paper.view.size.height };
      const endPoint = { x: paper.view.size.width, y: 0 };

      // Calculate diagonal distance
      const diagonalLength = Math.sqrt(
        Math.pow(endPoint.x - startPoint.x, 2) +
        Math.pow(endPoint.y - startPoint.y, 2)
      );

      // Unit vector along diagonal
      const directionX = (endPoint.x - startPoint.x) / diagonalLength;
      const directionY = (endPoint.y - startPoint.y) / diagonalLength;

      // Perpendicular vector (for band width)
      const perpX = -directionY;
      const perpY = directionX;

      // Clear existing segments
      centerLine.removeSegments();
      upperBoundary.removeSegments();
      lowerBoundary.removeSegments();

      // Ensure paths are not closed
      centerLine.closed = false;
      upperBoundary.closed = false;
      lowerBoundary.closed = false;

      // Generate points along the diagonal
      for (let t = 0; t <= diagonalLength; t += 5) {
        // Position along the diagonal
        const baseX = startPoint.x + directionX * t;
        const baseY = startPoint.y + directionY * t;

        // Sine wave offset
        const sineOffset = Math.sin(t * sineFrequency) * sineAmplitude;

        // Center line point
        const centerX = baseX + perpX * sineOffset;
        const centerY = baseY + perpY * sineOffset;
        centerLine.add(new paper.Point(centerX, centerY));

        // Upper boundary point
        const upperOffset = sineOffset + bandWidth / 2;
        const upperX = baseX + perpX * upperOffset;
        const upperY = baseY + perpY * upperOffset;
        upperBoundary.add(new paper.Point(upperX, upperY));

        // Lower boundary point
        const lowerOffset = sineOffset - bandWidth / 2;
        const lowerX = baseX + perpX * lowerOffset;
        const lowerY = baseY + perpY * lowerOffset;
        lowerBoundary.add(new paper.Point(lowerX, lowerY));
      }
    };

    const drawVerticalGuides = (centerLine: paper.Path, upperBoundary: paper.Path, lowerBoundary: paper.Path) => {
      // Get current preset config
      const preset = configPresets[targetPresetName as keyof typeof configPresets];
      const bandWidth = preset.distribution.bandWidth;

      // Get positioning parameters (with defaults for backward compatibility)
      const horizontalPosition = (preset.distribution as any).horizontalPosition || 0.5;
      const angleDegrees = (preset.distribution as any).angle || 0;

      // Convert angle to radians
      const angleRadians = (angleDegrees * Math.PI) / 180;

      // Calculate base X position from horizontal position (0-1 fraction of screen width)
      const baseX = paper.view.size.width * horizontalPosition;

      // Calculate horizontal offset per vertical unit based on angle
      // Negative angle tilts left (top moves left), positive tilts right (top moves right)
      const height = paper.view.size.height;
      const horizontalOffset = Math.tan(angleRadians) * height;

      // Calculate the actual line direction vector (from bottom to top)
      // Bottom point: (baseX - horizontalOffset/2, height)
      // Top point: (baseX + horizontalOffset/2, 0)
      const lineDirX = horizontalOffset; // Change in X from bottom to top
      const lineDirY = -height; // Change in Y from bottom to top (negative because y decreases)

      // Calculate perpendicular vector (rotate line direction 90° counter-clockwise)
      // Perpendicular of (dx, dy) is (-dy, dx)
      const perpDirX = -lineDirY; // = height
      const perpDirY = lineDirX; // = horizontalOffset

      // Normalize the perpendicular vector
      const perpLength = Math.sqrt(perpDirX * perpDirX + perpDirY * perpDirY);
      const perpX = perpDirX / perpLength;
      const perpY = perpDirY / perpLength;

      // Clear existing segments
      centerLine.removeSegments();
      upperBoundary.removeSegments();
      lowerBoundary.removeSegments();

      // Ensure paths are not closed
      centerLine.closed = false;
      upperBoundary.closed = false;
      lowerBoundary.closed = false;

      // Generate points along angled line from bottom to top
      for (let y = 0; y <= height; y += 5) {
        // Progress along the line (0 at bottom, 1 at top)
        const progress = y / height;

        // X position along the angled line
        // At bottom (y=height): baseX - horizontalOffset/2
        // At top (y=0): baseX + horizontalOffset/2
        const x = baseX + horizontalOffset * (0.5 - progress);

        // Center line
        centerLine.add(new paper.Point(x, y));

        // Upper and lower boundaries (perpendicular to the line)
        const upperX = x + perpX * (bandWidth / 2);
        const upperY = y + perpY * (bandWidth / 2);
        upperBoundary.add(new paper.Point(upperX, upperY));

        const lowerX = x - perpX * (bandWidth / 2);
        const lowerY = y - perpY * (bandWidth / 2);
        lowerBoundary.add(new paper.Point(lowerX, lowerY));
      }
    };

    const drawCircularGuides = (centerLine: paper.Path, upperBoundary: paper.Path, lowerBoundary: paper.Path) => {
      // Get current preset config
      const preset = configPresets[targetPresetName as keyof typeof configPresets];
      const bandWidth = preset.distribution.bandWidth;
      const circleRadius = (preset.distribution as any).circleRadius || 500;
      const circleOffsetY = (preset.distribution as any).circleOffsetY || 0;

      // Center of the circle (offset vertically to touch bottom)
      const centerX = paper.view.size.width / 2;
      const centerY = paper.view.size.height - circleRadius + circleOffsetY;

      // Clear existing segments
      centerLine.removeSegments();
      upperBoundary.removeSegments();
      lowerBoundary.removeSegments();

      // Generate points around the circle
      const angleStep = 0.02; // Smaller step for smoother circle
      for (let angle = 0; angle <= Math.PI * 2; angle += angleStep) {
        // Center line point
        const centerPointX = centerX + circleRadius * Math.cos(angle);
        const centerPointY = centerY + circleRadius * Math.sin(angle);
        centerLine.add(new paper.Point(centerPointX, centerPointY));

        // Upper boundary (outer circle)
        const outerX = centerX + (circleRadius + bandWidth / 2) * Math.cos(angle);
        const outerY = centerY + (circleRadius + bandWidth / 2) * Math.sin(angle);
        upperBoundary.add(new paper.Point(outerX, outerY));

        // Lower boundary (inner circle)
        const innerX = centerX + (circleRadius - bandWidth / 2) * Math.cos(angle);
        const innerY = centerY + (circleRadius - bandWidth / 2) * Math.sin(angle);
        lowerBoundary.add(new paper.Point(innerX, innerY));
      }

      // Close the paths to complete the circle
      centerLine.closed = true;
      upperBoundary.closed = true;
      lowerBoundary.closed = true;
    };

    const drawCurveGuides = (centerLine: paper.Path, upperBoundary: paper.Path, lowerBoundary: paper.Path) => {
      // Get current preset config
      const preset = configPresets[targetPresetName as keyof typeof configPresets];
      const bandWidth = preset.distribution.bandWidth;
      const controlPoints = (preset.distribution as any).curveControlPoints;

      if (!controlPoints || controlPoints.length !== 4) {
        console.error('Curve pattern requires exactly 4 control points for guides');
        return;
      }

      // Convert control points to pixel coordinates
      const p0 = { x: controlPoints[0].x * paper.view.size.width, y: controlPoints[0].y * paper.view.size.height };
      const p1 = { x: controlPoints[1].x * paper.view.size.width, y: controlPoints[1].y * paper.view.size.height };
      const p2 = { x: controlPoints[2].x * paper.view.size.width, y: controlPoints[2].y * paper.view.size.height };
      const p3 = { x: controlPoints[3].x * paper.view.size.width, y: controlPoints[3].y * paper.view.size.height };

      // Clear existing segments
      centerLine.removeSegments();
      upperBoundary.removeSegments();
      lowerBoundary.removeSegments();

      // Ensure paths are not closed
      centerLine.closed = false;
      upperBoundary.closed = false;
      lowerBoundary.closed = false;

      // Sample points along the Bezier curve
      for (let t = 0; t <= 1; t += 0.01) { // Sample every 1%
        // Get point on curve
        const curvePoint = bezierPoint(t, p0, p1, p2, p3);

        // Get perpendicular direction at this point
        const tangent = bezierTangent(t, p0, p1, p2, p3);
        const perpX = -tangent.dy;
        const perpY = tangent.dx;
        const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        const perpNormX = perpX / perpLength;
        const perpNormY = perpY / perpLength;

        // Center line
        centerLine.add(new paper.Point(curvePoint.x, curvePoint.y));

        // Upper boundary (offset perpendicular)
        const upperX = curvePoint.x + perpNormX * (bandWidth / 2);
        const upperY = curvePoint.y + perpNormY * (bandWidth / 2);
        upperBoundary.add(new paper.Point(upperX, upperY));

        // Lower boundary (offset perpendicular)
        const lowerX = curvePoint.x - perpNormX * (bandWidth / 2);
        const lowerY = curvePoint.y - perpNormY * (bandWidth / 2);
        lowerBoundary.add(new paper.Point(lowerX, lowerY));
      }
    };

    // Create guide paths (will be dynamically updated)
    const guidePaths = {
      centerLine: new paper.Path(),
      upperBoundary: new paper.Path(),
      lowerBoundary: new paper.Path()
    };

    // Configure guide appearance
    guidePaths.centerLine.strokeColor = new paper.Color('#FF0000');
    guidePaths.centerLine.strokeWidth = 2;
    guidePaths.centerLine.opacity = 0.3;
    guidePaths.centerLine.dashArray = [10, 5];

    guidePaths.upperBoundary.strokeColor = new paper.Color('#FFFFFF');
    guidePaths.upperBoundary.strokeWidth = 1;
    guidePaths.upperBoundary.opacity = 0.2;
    guidePaths.upperBoundary.dashArray = [5, 5];

    guidePaths.lowerBoundary.strokeColor = new paper.Color('#FFFFFF');
    guidePaths.lowerBoundary.strokeWidth = 1;
    guidePaths.lowerBoundary.opacity = 0.2;
    guidePaths.lowerBoundary.dashArray = [5, 5];

    // Function to update guides based on current pattern
    const updateGuides = () => {
      const currentPreset = configPresets[targetPresetName as keyof typeof configPresets];
      const pattern = currentPreset.pattern;

      if (pattern === 'curve') {
        drawCurveGuides(guidePaths.centerLine, guidePaths.upperBoundary, guidePaths.lowerBoundary);
      } else if (pattern === 'vertical') {
        drawVerticalGuides(guidePaths.centerLine, guidePaths.upperBoundary, guidePaths.lowerBoundary);
      } else if (pattern === 'circle') {
        drawCircularGuides(guidePaths.centerLine, guidePaths.upperBoundary, guidePaths.lowerBoundary);
      } else {
        drawDiagonalGuides(guidePaths.centerLine, guidePaths.upperBoundary, guidePaths.lowerBoundary);
      }
    };

    // Initialize guides with current pattern
    updateGuides();

    // TOGGLE GUIDE VISIBILITY: Set to false to hide the guides
    const showGuides = true;
    if (!showGuides) {
      guidePaths.centerLine.visible = false;
      guidePaths.upperBoundary.visible = false;
      guidePaths.lowerBoundary.visible = false;
    }

    // Create shapes
    const shapes: paper.Path[] = [];

    shapesData.forEach(shapeData => {
      let shape: paper.Path | paper.Shape;

      switch(shapeData.type) {
        case 'circle':
          shape = new paper.Path.Circle({
            center: [shapeData.x, shapeData.y],
            radius: shapeData.radius,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          break;

        case 'rect':
          shape = new paper.Path.Rectangle({
            point: [shapeData.x - shapeData.width/2, shapeData.y - shapeData.height/2],
            size: [shapeData.width, shapeData.height],
            radius: shapeData.radius || 0,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          // Set position to center after creation
          shape.position = new paper.Point(shapeData.x, shapeData.y);
          if (shapeData.rotation) {
            shape.rotate(shapeData.rotation, shape.position);
          }
          break;

        case 'triangle':
          shape = new paper.Path.RegularPolygon({
            center: [shapeData.x, shapeData.y],
            sides: 3,
            radius: shapeData.size,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          if (shapeData.rotation) {
            shape.rotate(shapeData.rotation);
          }
          // shape.smooth();
          shape.segments.forEach(segment => {
            segment.smooth();
          });
          break;

        case 'line':
          shape = new paper.Path.Line({
            from: [shapeData.x1, shapeData.y1],
            to: [shapeData.x2, shapeData.y2],
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
            strokeCap: 'round',
          });
          break;

        default:
          return;
      }

      // Add background fill to hide connection lines behind shapes
      // (except for line shapes which don't need fills)
      if (shapeData.type !== 'line') {
        shape.fillColor = new paper.Color(colors.background);
      }

      // Apply blur effect to some shapes randomly
      if (shapeConfig.blur.enabled && Math.random() < shapeConfig.blur.probability) {
        shape.shadowBlur = shapeConfig.blur.amount;
        shape.shadowColor = shape.strokeColor;
      }

      // Store original position and lifecycle data
      const initialLifespan = shapeConfig.lifespan.min + Math.random() * (shapeConfig.lifespan.max - shapeConfig.lifespan.min);
      shape.data = {
        originalPosition: shape.position.clone(),
        originalRotation: shapeData.rotation || 0,
        floatPhaseY: Math.random() * Math.PI * 2, // Y-axis phase
        floatPhaseX: Math.random() * Math.PI * 2, // X-axis phase (different)
        rotationSpeed: shapeConfig.rotationSpeed.min + Math.random() * (shapeConfig.rotationSpeed.max - shapeConfig.rotationSpeed.min),
        floatSpeedY: shapeConfig.floatSpeed.yMin + Math.random() * (shapeConfig.floatSpeed.yMax - shapeConfig.floatSpeed.yMin),
        floatSpeedX: shapeConfig.floatSpeed.xMin + Math.random() * (shapeConfig.floatSpeed.xMax - shapeConfig.floatSpeed.xMin),
        amplitudeY: shapeConfig.amplitude.yMin + Math.random() * (shapeConfig.amplitude.yMax - shapeConfig.amplitude.yMin),
        amplitudeX: shapeConfig.amplitude.xMin + Math.random() * (shapeConfig.amplitude.xMax - shapeConfig.amplitude.xMin),
        // Lifecycle properties
        age: 0,
        lifespan: initialLifespan,
        originalLifespan: initialLifespan, // Track original lifespan to detect extensions
        baseX: shapeData.x, // Original X for respawn
        baseY: shapeData.y, // Original Y for respawn
        shapeType: shapeData.type,
        // Firing properties
        isFiring: false,
        fireIntensity: 0,
        fireDecay: shapeConfig.firing.decay,
        originalStrokeWidth: shapeData.strokeWidth,
        originalStrokeColor: shapeData.strokeColor,
        lastFireTime: connectionConfig.initialization.initialFireTime, // Last time this shape fired (frame number)
        fireCooldown: shapeConfig.firing.cooldown,
        lifespanExtension: shapeConfig.firing.lifespanExtension,
      };

      shapes.push(shape);
    });

    console.log(`Created ${shapes.length} shapes`);

    // Create neuron-like connections between nearby shapes
    const connections: any[] = [];

    const createConnections = () => {
      shapes.forEach((shape, i) => {
        shapes.forEach((otherShape, j) => {
          if (i >= j) return; // Avoid duplicate connections and self-connections

          const dx = otherShape.position.x - shape.position.x;
          const dy = otherShape.position.y - shape.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Only connect if within range and moving towards top-right direction
          // (target shape should be to the right and/or above)
          if (distance < connectionConfig.maxDistance &&
              (dx > 0 || dy < 0) && // Right or up
              Math.random() < connectionConfig.probability) {

            // Create line with gradient-like color effect
            const line = new paper.Path.Line({
              from: shape.position,
              to: otherShape.position,
              strokeColor: new paper.Color(colors.secondary), // Will be updated in animation loop
              strokeWidth: connectionConfig.staticStrokeWidth,
              opacity: connectionConfig.staticOpacity,
              dashArray: connectionConfig.staticDashArray,
            });

            // Store connection data
            line.data = {
              startShape: shape,
              endShape: otherShape,
              age: Math.random() * connectionConfig.initialization.maxAge, // Random starting age for staggered animation
              pulseSpeed: connectionConfig.pulseSpeed.min + Math.random() * (connectionConfig.pulseSpeed.max - connectionConfig.pulseSpeed.min),
              travelingPulses: [], // Array of pulses traveling along this connection
            };

            connections.push(line);
          }
        });
      });
    };

    createConnections();
    console.log(`Created ${connections.length} neuron connections`);

    // Send all connection lines to the back so shapes are drawn on top
    connections.forEach(connection => {
      connection.sendToBack();
    });

    // Regenerate connections for a specific shape
    const regenerateConnectionsForShape = (shape: paper.Path, index: number) => {
      // Create new connections FROM this shape to nearby shapes (outgoing)
      shapes.forEach((otherShape, j) => {
        if (index === j) return; // Skip self

        const dx = otherShape.position.x - shape.position.x;
        const dy = otherShape.position.y - shape.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Only connect if within range and moving towards top-right direction
        if (distance < connectionConfig.maxDistance &&
            (dx > 0 || dy < 0) && // Right or up
            Math.random() < connectionConfig.probability) {

          const line = new paper.Path.Line({
            from: shape.position,
            to: otherShape.position,
            strokeColor: new paper.Color(colors.secondary), // Will be updated in animation loop
            strokeWidth: connectionConfig.staticStrokeWidth,
            opacity: connectionConfig.staticOpacity,
            dashArray: connectionConfig.staticDashArray,
          });

          line.data = {
            startShape: shape,
            endShape: otherShape,
            age: Math.random() * connectionConfig.initialization.maxAge,
            pulseSpeed: connectionConfig.pulseSpeed.min + Math.random() * (connectionConfig.pulseSpeed.max - connectionConfig.pulseSpeed.min),
            travelingPulses: [],
          };

          line.sendToBack(); // Keep connection behind shapes
          connections.push(line);
        }
      });

      // Create new connections TO this shape from nearby shapes (incoming)
      shapes.forEach((otherShape, j) => {
        if (index === j) return; // Skip self

        const dx = shape.position.x - otherShape.position.x;
        const dy = shape.position.y - otherShape.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Only connect if within range and moving towards top-right direction
        if (distance < connectionConfig.maxDistance &&
            (dx > 0 || dy < 0) && // Right or up
            Math.random() < connectionConfig.probability) {

          const line = new paper.Path.Line({
            from: otherShape.position,
            to: shape.position,
            strokeColor: new paper.Color(colors.secondary), // Will be updated in animation loop
            strokeWidth: connectionConfig.staticStrokeWidth,
            opacity: connectionConfig.staticOpacity,
            dashArray: connectionConfig.staticDashArray,
          });

          line.data = {
            startShape: otherShape,
            endShape: shape,
            age: Math.random() * connectionConfig.initialization.maxAge,
            pulseSpeed: connectionConfig.pulseSpeed.min + Math.random() * (connectionConfig.pulseSpeed.max - connectionConfig.pulseSpeed.min),
            travelingPulses: [],
          };

          line.sendToBack(); // Keep connection behind shapes
          connections.push(line);
        }
      });
    };

    // Counters for equal distribution of shapes, colors, and stroke widths
    let shapeTypeCounter = 0;
    let colorCounter = 0;
    let strokeWidthCounter = 0;

    // Easing functions for smoother motion
    const easeInOutSine = (t: number) => -(Math.cos(Math.PI * t) - 1) / 2;
    const easeInOutCubic = (t: number) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

    // Helper function to regenerate a shape with equal distribution
    const regenerateShape = (shape: paper.Path, index: number) => {
      const oldShape = shape; // Store reference to old shape before removal

      // Remove all connections that reference this old shape
      for (let i = connections.length - 1; i >= 0; i--) {
        const conn = connections[i];
        if (conn.data.startShape === oldShape || conn.data.endShape === oldShape) {
          // Clean up any traveling pulses
          conn.data.travelingPulses.forEach((pulse: any) => {
            if (pulse.segment) {
              pulse.segment.remove();
            }
          });
          conn.remove();
          connections.splice(i, 1);
        }
      }

      // Generate new position based on current target pattern (for morphing)
      const newPosition = generateSingleShapePosition(shapes);
      const newX = newPosition.x;
      const newY = newPosition.y;

      // Equal distribution of shape types (cycle through)
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const newType = shapeTypes[shapeTypeCounter % shapeTypes.length];
      shapeTypeCounter++;

      // Equal distribution of sizes for each type
      const sizes = shapeConfig.sizes;
      const sizeOptions = sizes[newType as keyof typeof sizes];
      const sizeIndex = Math.floor(Math.random() * sizeOptions.length); // Keep size random within type
      const newSize = sizeOptions[sizeIndex] || shapeConfig.regeneration.defaultSizeFallback;

      // Equal distribution of colors (cycle through)
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const newColor = colorOptions[colorCounter % colorOptions.length];
      colorCounter++;

      // Equal distribution of stroke widths (cycle through)
      const strokeWidthOptions = shapeConfig.appearance.strokeWidthOptions;
      const newStrokeWidth = strokeWidthOptions[strokeWidthCounter % strokeWidthOptions.length];
      strokeWidthCounter++;

      // Random rotation
      const newRotation = Math.random() * shapeConfig.appearance.initialRotation;

      // Remove old shape
      shape.remove();

      // Create new shape
      let newShape: paper.Path | paper.Shape;

      switch(newType) {
        case 'circle':
          newShape = new paper.Path.Circle({
            center: [newX, newY],
            radius: newSize,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          break;

        case 'rect':
          newShape = new paper.Path.Rectangle({
            point: [newX - newSize/2, newY - newSize/2],
            size: [newSize, newSize],
            radius: Math.random() > 0.5 ? 2.5 : 4.5,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          newShape.position = new paper.Point(newX, newY);
          newShape.rotate(newRotation, newShape.position);
          break;

        case 'triangle':
          newShape = new paper.Path.RegularPolygon({
            center: [newX, newY],
            sides: 3,
            radius: newSize,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          newShape.rotate(newRotation);
          // newShape.smooth();
          newShape.segments.forEach(segment => {
          segment.smooth();
        });
          break;

        default:
          return;
      }

      // Add background fill to hide connection lines behind shapes
      newShape.fillColor = new paper.Color(colors.background);

      // Apply blur effect to some shapes randomly
      if (shapeConfig.blur.enabled && Math.random() < shapeConfig.blur.probability) {
        newShape.shadowBlur = shapeConfig.blur.amount;
        newShape.shadowColor = newShape.strokeColor;
      }

      // Reset lifecycle data with new randomized values
      const regeneratedLifespan = shapeConfig.lifespan.min + Math.random() * (shapeConfig.lifespan.max - shapeConfig.lifespan.min);
      newShape.data = {
        originalPosition: newShape.position.clone(),
        originalRotation: newRotation,
        floatPhaseY: Math.random() * Math.PI * 2,
        floatPhaseX: Math.random() * Math.PI * 2,
        rotationSpeed: shapeConfig.rotationSpeed.min + Math.random() * (shapeConfig.rotationSpeed.max - shapeConfig.rotationSpeed.min),
        floatSpeedY: shapeConfig.floatSpeed.yMin + Math.random() * (shapeConfig.floatSpeed.yMax - shapeConfig.floatSpeed.yMin),
        floatSpeedX: shapeConfig.floatSpeed.xMin + Math.random() * (shapeConfig.floatSpeed.xMax - shapeConfig.floatSpeed.xMin),
        amplitudeY: shapeConfig.amplitude.yMin + Math.random() * (shapeConfig.amplitude.yMax - shapeConfig.amplitude.yMin),
        amplitudeX: shapeConfig.amplitude.xMin + Math.random() * (shapeConfig.amplitude.xMax - shapeConfig.amplitude.xMin),
        age: 0,
        lifespan: regeneratedLifespan,
        originalLifespan: regeneratedLifespan, // Track original lifespan
        baseX: newX, // Store new position as base
        baseY: newY,
        shapeType: newType,
        // Firing properties
        isFiring: false,
        fireIntensity: 0,
        fireDecay: shapeConfig.firing.decay,
        originalStrokeWidth: newStrokeWidth,
        originalStrokeColor: newColor,
        lastFireTime: connectionConfig.initialization.initialFireTime,
        fireCooldown: shapeConfig.firing.cooldown,
        lifespanExtension: shapeConfig.firing.lifespanExtension,
      };

      // Replace in shapes array
      shapes[index] = newShape;

      // Regenerate connections for this new shape
      regenerateConnectionsForShape(newShape, index);
    };

    // Helper function to trigger a shape to fire
    const fireShape = (shape: paper.Path, currentFrame: number) => {
      // Safety check: ensure shape is still valid and in the shapes array
      if (!shape || !shape.data || !shapes.includes(shape)) {
        return;
      }

      // Check cooldown: prevent firing too frequently
      const timeSinceLastFire = currentFrame - shape.data.lastFireTime;
      if (timeSinceLastFire < shape.data.fireCooldown) {
        return; // Still in cooldown, don't fire
      }

      if (!shape.data.isFiring) {
        shape.data.isFiring = true;
        shape.data.fireIntensity = 1.0;
        shape.data.lastFireTime = currentFrame; // Update last fire time

        // Extend lifespan - active neurons live longer
        shape.data.lifespan += shape.data.lifespanExtension;

        // Send pulses along all outgoing connections
        connections.forEach((connection) => {
          if (connection.data.startShape === shape) {
            // Add a traveling pulse with random speed for organic variation
            const speedRange = connectionConfig.pulseSpeed.max - connectionConfig.pulseSpeed.min;
            connection.data.travelingPulses.push({
              progress: 0, // 0 = start, 1 = end
              speed: connectionConfig.pulseSpeed.min + Math.random() * speedRange,
              hasFired: false, // Track if target neuron has been fired
            });
          }
        });
      }
    };

    // Track current frame for mouse interaction
    let currentFrameCount = 0;

    // Death rate acceleration during transitions
    let isTransitioning = false;
    let acceleratedDeathRate = 1.0; // 1.0 = normal, higher = faster death

    // Guide transition state
    let guideMorphProgress = 1.0; // 1.0 = fully morphed, 0.0 = start of morph
    let guideFadeOut = false;
    let guideFadeIn = false;
    const guideTransitionSpeed = 0.05; // Speed of guide morphing

    // Listen for scroll section changes
    window.addEventListener('message', (event) => {
      if (event.data.type === 'section-change') {
        const section = event.data.section as keyof typeof configPresets;
        if (configPresets[section]) {
          const oldPattern = configPresets[currentPresetName as keyof typeof configPresets].pattern;
          const newPattern = configPresets[section].pattern;

          targetPresetName = section;
          transitionProgress = 0; // Start transition

          // If pattern is changing, activate accelerated death rate
          if (oldPattern !== newPattern) {
            console.log(`Pattern changing from ${oldPattern} to ${newPattern} - accelerating death rate`);
            isTransitioning = true;
            acceleratedDeathRate = 5.0; // Shapes die 5x faster during transition

            // Start guide morphing sequence: fade out -> update -> fade in
            guideMorphProgress = 0.0;
            guideFadeOut = true;
            guideFadeIn = false;
          }

          console.log(`Background transitioning to ${section} preset`);
        }
      }
    });

    // Smooth lerp function
    const lerp = (start: number, end: number, t: number) => start + (end - start) * t;

    // Organic floating animations - each shape moves independently in X and Y with easing
    paper.view.onFrame = (event: any) => {
      const time = event.count;
      currentFrameCount = time;

      // Handle config transitions
      if (transitionProgress < 1) {
        transitionProgress += 0.02; // Smooth transition over ~50 frames (~0.8s)
        if (transitionProgress > 1) transitionProgress = 1;

        // Update config when transition completes
        if (transitionProgress >= 1 && currentPresetName !== targetPresetName) {
          currentPresetName = targetPresetName;
          const preset = configPresets[currentPresetName as keyof typeof configPresets];

          if (preset) {
            shapeConfig = buildShapeConfig(preset);
            console.log(`Background config updated to ${currentPresetName} - shapes will morph gradually`);
          }
        }
      }

      // Gradually reduce death rate back to normal after transition
      if (isTransitioning) {
        if (acceleratedDeathRate > 1.0) {
          acceleratedDeathRate -= 0.05; // Gradually slow down death rate
          if (acceleratedDeathRate <= 1.0) {
            acceleratedDeathRate = 1.0;
            isTransitioning = false;
            console.log('Death rate returned to normal');
          }
        }
      }

      // Handle guide morphing animation
      if (guideFadeOut || guideFadeIn) {
        guideMorphProgress += guideTransitionSpeed;

        if (guideFadeOut) {
          // Fade out phase (0.0 to 0.5)
          if (guideMorphProgress >= 0.5) {
            // Fade out complete - update the guide shapes
            updateGuides();
            guideFadeOut = false;
            guideFadeIn = true;
            console.log('Guides updated - starting fade in');
          } else {
            // Fade out in progress (opacity: 1.0 -> 0.0)
            const fadeOutOpacity = 1.0 - (guideMorphProgress / 0.5);
            guidePaths.centerLine.opacity = 0.3 * fadeOutOpacity;
            guidePaths.upperBoundary.opacity = 0.2 * fadeOutOpacity;
            guidePaths.lowerBoundary.opacity = 0.2 * fadeOutOpacity;
          }
        } else if (guideFadeIn) {
          // Fade in phase (0.5 to 1.0)
          if (guideMorphProgress >= 1.0) {
            // Fade in complete - finish morphing
            guideMorphProgress = 1.0;
            guideFadeIn = false;
            guidePaths.centerLine.opacity = 0.3;
            guidePaths.upperBoundary.opacity = 0.2;
            guidePaths.lowerBoundary.opacity = 0.2;
            console.log('Guide morphing complete');
          } else {
            // Fade in in progress (opacity: 0.0 -> 1.0)
            const fadeInOpacity = (guideMorphProgress - 0.5) / 0.5;
            guidePaths.centerLine.opacity = 0.3 * fadeInOpacity;
            guidePaths.upperBoundary.opacity = 0.2 * fadeInOpacity;
            guidePaths.lowerBoundary.opacity = 0.2 * fadeInOpacity;
          }
        }
      }

      // Randomly trigger fires from shapes (neural activity) - reduced frequency
      if (Math.random() < shapeConfig.fireEffects.randomFireProbability) {
        const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
        if (randomShape) {
          fireShape(randomShape, time);
        }
      }

      shapes.forEach((shape, index) => {
        // Regenerate before incrementing age if lifecycle is complete
        if (shape.data.age >= shape.data.lifespan) {
          regenerateShape(shape, index);
          // Get the newly regenerated shape
          const regeneratedShape = shapes[index];
          if (!regeneratedShape) return;
          shape = regeneratedShape;
        }

        // Increment age (apply accelerated death rate during transitions)
        shape.data.age += acceleratedDeathRate;

        // Calculate fade in/out opacity based on lifecycle (linear)
        const fadeInDuration = shapeConfig.fade.fadeInDuration;
        const fadeOutDuration = shapeConfig.fade.fadeOutDuration;
        const age = shape.data.age;
        const lifespan = shape.data.lifespan;

        let baseOpacity = 1;

        // Fade in at the beginning (linear)
        if (age <= fadeInDuration) {
          baseOpacity = age / fadeInDuration;
        }
        // Fade out at the end (linear)
        else if (age >= lifespan - fadeOutDuration) {
          baseOpacity = Math.max(0, (lifespan - age) / fadeOutDuration);
        }

        // Check if lifespan has been extended (node has fired and been rewarded)
        const hasExtendedLifespan = shape.data.lifespan > shape.data.originalLifespan;

        // Apply opacity based on state:
        // - Normal idle nodes: 0.2 opacity (very subtle)
        // - Firing nodes: 1.0 opacity (full brightness)
        // - Extended lifespan nodes: 1.0 opacity (rewarded for activity)
        if (shape.data.isFiring || hasExtendedLifespan) {
          shape.opacity = baseOpacity * 1.0; // Full opacity
        } else {
          shape.opacity = baseOpacity * 0.2; // Very low opacity (1/5)
        }

        // Handle firing state (glow effect)
        if (shape.data.isFiring) {
          shape.data.fireIntensity -= shape.data.fireDecay;
          if (shape.data.fireIntensity <= 0) {
            shape.data.isFiring = false;
            shape.data.fireIntensity = 0;
          }
        }

        // Apply glow effect and background tint based on firing state
        if (shape.data.fireIntensity > 0) {
          // FIRING: Increase stroke width to create glow
          shape.strokeWidth = shape.data.originalStrokeWidth + shape.data.fireIntensity * shapeConfig.fireEffects.glowStrokeMultiplier;

          // FIRING: Brighten the stroke color
          const glowColor = new paper.Color(shape.data.originalStrokeColor);
          glowColor.brightness += shape.data.fireIntensity * shapeConfig.fireEffects.glowBrightnessMultiplier;
          shape.strokeColor = glowColor;
        } else {
          // IDLE: Restore to original stroke appearance
          shape.strokeWidth = shape.data.originalStrokeWidth;
          shape.strokeColor = new paper.Color(shape.data.originalStrokeColor);
        }

        // Raw sine wave values (oscillating between -1 and 1)
        const rawSinY = Math.sin(time * shape.data.floatSpeedY + shape.data.floatPhaseY);
        const rawSinX = Math.sin(time * shape.data.floatSpeedX + shape.data.floatPhaseX);

        // Normalize to 0-1 range for easing function
        const normalizedY = (rawSinY + 1) / 2; // Convert -1..1 to 0..1
        const normalizedX = (rawSinX + 1) / 2;

        // Apply easing (creates smoother acceleration/deceleration)
        const easedY = easeInOutSine(normalizedY);
        const easedX = easeInOutSine(normalizedX);

        // Convert back to -1..1 range and apply amplitude
        const floatOffsetY = (easedY * 2 - 1) * shape.data.amplitudeY;
        const floatOffsetX = (easedX * 2 - 1) * shape.data.amplitudeX;

        // Apply both movements
        shape.position.x = shape.data.originalPosition.x + floatOffsetX;
        shape.position.y = shape.data.originalPosition.y + floatOffsetY;

        // Gentle rotation with easing
        const rotationEase = easeInOutSine(normalizedY);
        shape.rotate(shape.data.rotationSpeed * 60 * (rotationEase * 2 - 1));
      });

      // Animate neuron connections
      for (let i = connections.length - 1; i >= 0; i--) {
        const connection = connections[i];

        // Safety check: ensure both shapes are still valid
        const startShape = connection.data.startShape;
        const endShape = connection.data.endShape;

        if (!startShape || !endShape || !shapes.includes(startShape) || !shapes.includes(endShape)) {
          // Clean up invalid connection
          connection.data.travelingPulses.forEach((pulse: any) => {
            if (pulse.segment) pulse.segment.remove();
          });
          connection.remove();
          connections.splice(i, 1);
          continue;
        }

        // Update connection positions to follow shapes
        const startPos = startShape.position;
        const endPos = endShape.position;
        connection.segments[0].point = startPos;
        connection.segments[1].point = endPos;

        // Create gradient color from start node to end node
        const startNodeColor = new paper.Color(startShape.strokeColor);
        const endNodeColor = new paper.Color(endShape.strokeColor);

        // Create a linear gradient from start to end position
        const gradient = new paper.Color({
          gradient: {
            stops: [
              [startNodeColor, 0],
              [endNodeColor, 1]
            ]
          },
          origin: startPos,
          destination: endPos
        });

        connection.strokeColor = gradient;

        // Pulsing opacity animation (like neurons firing)
        connection.data.age += connection.data.pulseSpeed;
        const pulseValue = Math.sin(connection.data.age);
        connection.opacity = connectionConfig.pulseBaseOpacity +
          (pulseValue * connectionConfig.pulseVisuals.opacityMultiplier + connectionConfig.pulseVisuals.opacityOffset) * connectionConfig.pulseAmount;

        // Make connections fade with their connected shapes
        const startOpacity = connection.data.startShape.opacity;
        const endOpacity = connection.data.endShape.opacity;
        const minShapeOpacity = Math.min(startOpacity, endOpacity);
        connection.opacity *= minShapeOpacity;

        // Animate traveling pulses
        const pulses = connection.data.travelingPulses;
        for (let i = pulses.length - 1; i >= 0; i--) {
          const pulse = pulses[i];
          pulse.progress += pulse.speed;

          // Two-phase animation:
          // Phase 1: Line grows from A to B with easing
          // Phase 2: Line fades and shrinks from A side with easing
          const phase1Duration = connectionConfig.pulseGrowthPhase;
          const phase2Duration = connectionConfig.pulseFadePhase;

          let pulseStart = 0;
          let pulseEnd = 0;
          let opacity = 0.9;
          let strokeWidth = connectionConfig.pulseStrokeWidth.start;

          // Track if we've fired the target neuron yet
          if (!pulse.hasFired && pulse.progress >= phase1Duration) {
            // Fire the target neuron as soon as the pulse reaches it
            fireShape(connection.data.endShape, time);
            pulse.hasFired = true;
          }

          if (pulse.progress <= phase1Duration) {
            // Phase 1: Growing from A to B
            const t = pulse.progress / phase1Duration; // Normalize to 0-1
            const easedProgress = easeInOutCubic(t); // Apply easing

            pulseStart = 0;
            pulseEnd = easedProgress; // Grows from 0 to 1
            opacity = 0.9; // Full opacity during growth

            // Stroke width grows from start to peak
            strokeWidth = connectionConfig.pulseStrokeWidth.start +
              (connectionConfig.pulseStrokeWidth.peak - connectionConfig.pulseStrokeWidth.start) * easedProgress;
          } else {
            // Phase 2: Shrinking from start while fading
            const t = (pulse.progress - phase1Duration) / phase2Duration; // Normalize to 0-1
            const easedProgress = easeInOutCubic(t); // Apply easing

            pulseStart = easedProgress; // Shrinks from 0 to 1
            pulseEnd = 1; // Stays at end
            opacity = 0.9 * (1 - easedProgress); // Fade out as it shrinks

            // Stroke width shrinks from peak to end
            strokeWidth = connectionConfig.pulseStrokeWidth.peak +
              (connectionConfig.pulseStrokeWidth.end - connectionConfig.pulseStrokeWidth.peak) * easedProgress;
          }

          // Create gradient effect: interpolate color from start to end along the pulse
          const startColor = new paper.Color(startShape.strokeColor);
          const endColor = new paper.Color(endShape.strokeColor);

          // For gradient effect, we need to create a path with gradient stroke
          // Since Paper.js doesn't support gradient strokes directly, we'll use the average color
          // weighted by the pulse position for a smooth transition
          const averagePosition = (pulseStart + pulseEnd) / 2; // Midpoint of the pulse
          const pulseColor = startColor.clone();

          // Lerp between start and end color based on the pulse's average position
          pulseColor.red = startColor.red + (endColor.red - startColor.red) * averagePosition;
          pulseColor.green = startColor.green + (endColor.green - startColor.green) * averagePosition;
          pulseColor.blue = startColor.blue + (endColor.blue - startColor.blue) * averagePosition;

          if (!pulse.segment) {
            pulse.segment = new paper.Path.Line({
              from: startPos.add(endPos.subtract(startPos).multiply(pulseStart)),
              to: startPos.add(endPos.subtract(startPos).multiply(pulseEnd)),
              strokeColor: pulseColor,
              strokeWidth: strokeWidth,
              strokeCap: 'round',
            });

            // Apply blur effect to traveling pulse
            if (connectionConfig.pulseBlur.enabled) {
              pulse.segment.shadowBlur = connectionConfig.pulseBlur.amount;
              pulse.segment.shadowColor = pulseColor;
            }

            // Send pulse to back so it appears behind shapes
            pulse.segment.sendToBack();
          } else {
            // Update segment position, color, and stroke width
            pulse.segment.segments[0].point = startPos.add(endPos.subtract(startPos).multiply(pulseStart));
            pulse.segment.segments[1].point = startPos.add(endPos.subtract(startPos).multiply(pulseEnd));
            pulse.segment.strokeColor = pulseColor;
            pulse.segment.strokeWidth = strokeWidth;

            // Update shadow color to match pulse color
            if (connectionConfig.pulseBlur.enabled) {
              pulse.segment.shadowColor = pulseColor;
            }
          }

          // Apply the calculated opacity
          pulse.segment.opacity = opacity;

          // If pulse completed both phases, clean up
          if (pulse.progress >= 1) {
            if (pulse.segment) {
              pulse.segment.remove(); // Clean up the pulse segment
            }
            pulses.splice(i, 1); // Remove completed pulse
          }
        }
      }
    };

    console.log('Animation loop started');

    // Mouse interaction - fire nodes on hover
    let lastHoveredShape: paper.Path | null = null;

    paper.view.onMouseMove = (event: any) => {
      const hitResult = paper.project.hitTest(event.point, {
        fill: true,
        stroke: true,
        tolerance: 5
      });

      if (hitResult && hitResult.item) {
        // Check if the hit item is one of our shapes
        const hoveredShape = shapes.find(s => s === hitResult.item);

        if (hoveredShape && hoveredShape !== lastHoveredShape) {
          // Fire the shape when mouse enters it
          fireShape(hoveredShape, currentFrameCount);
          lastHoveredShape = hoveredShape;
        }
      } else {
        // Mouse is not over any shape
        lastHoveredShape = null;
      }
    };

    // Handle resize
    window.addEventListener('resize', () => {
      paper.view.viewSize = new paper.Size(window.innerWidth, window.innerHeight);
    });
  }

  // Run when DOM is ready
  console.log('Script loaded! readyState:', document.readyState);

  if (document.readyState === 'loading') {
    console.log('Waiting for DOMContentLoaded...');
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded fired!');
      initPaperCanvas();
    });
  } else {
    console.log('DOM already ready, initializing immediately');
    initPaperCanvas();
  }
</script>