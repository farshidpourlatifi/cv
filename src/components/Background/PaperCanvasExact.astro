---
/**
 * PaperCanvasExact Component
 *
 * Paper.js canvas with exact shapes from bg.svg design
 * All positions, colors, and sizes match the original Figma design
 */
---

<div id="geometric-canvas-container" class="paper-canvas-container">
  <canvas id="geometric-canvas" resize></canvas>
</div>

<style>
  .paper-canvas-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
  }

  #geometric-canvas {
    width: 100%;
    height: 100%;
    pointer-events: auto;
  }
</style>

<script>
  import paper from 'paper';

  // Initialize Paper.js - run immediately since Astro scripts are deferred by default
  function initPaperCanvas() {
    const canvas = document.getElementById('geometric-canvas') as HTMLCanvasElement;
    if (!canvas) {
      console.error('Canvas not found!');
      return;
    }

    console.log('Initializing Paper.js...');

    // Setup Paper.js
    paper.setup(canvas);

    console.log('Paper.js setup complete');

    // Colors from the SVG design
    const colors = {
      primaryLight: '#004B72',
      secondary: '#3E9FD4',
      accent: '#F0000F',
      accentDark: '#E00514',
      tertiary: '#006BA5',
      white: '#FFFFFF',
    };

    // Generate shapes within a diagonal sine wave band (bottom-left to top-right)
    const generateShapesInDiagonalBand = () => {
      const generatedShapes: any[] = [];
      const minDistance = 50; // Minimum distance between shapes (lower = more dense)

      // Band parameters
      const bandWidth = 300; // Width of the band (perpendicular to diagonal)
      const sineAmplitude = 100; // Amplitude of sine wave oscillation
      const sineFrequency = 0.004; // Frequency of sine wave

      // Diagonal line from bottom-left to top-right
      const startPoint = { x: 0, y: paper.view.size.height };
      const endPoint = { x: paper.view.size.width, y: 0 };

      // Calculate diagonal distance
      const diagonalLength = Math.sqrt(
        Math.pow(endPoint.x - startPoint.x, 2) +
        Math.pow(endPoint.y - startPoint.y, 2)
      );

      // Unit vector along diagonal
      const directionX = (endPoint.x - startPoint.x) / diagonalLength;
      const directionY = (endPoint.y - startPoint.y) / diagonalLength;

      // Perpendicular vector (for band width)
      const perpX = -directionY;
      const perpY = directionX;

      // Shape types to cycle through for equal distribution
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const sizes = { circle: [15, 20, 10], rect: [15, 25, 20], triangle: [20, 15, 25] };
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const strokeWidthOptions = [1, 2, 5];

      // Counters for equal distribution
      let shapeCounter = 0;
      let colorCounter = 0;
      let strokeCounter = 0;

      // Check if position is too close to existing shapes
      const isTooClose = (x: number, y: number, existing: any[]) => {
        return existing.some(shape => {
          const dx = shape.x - x;
          const dy = shape.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < minDistance;
        });
      };

      // Generate shapes along the diagonal band
      const spacing = 5; // Spacing along the diagonal (lower = more attempts = more dense)

      for (let t = 50; t < diagonalLength - 50; t += spacing + Math.random() * 3) {
        // Position along the diagonal
        const baseX = startPoint.x + directionX * t;
        const baseY = startPoint.y + directionY * t;

        // Sine wave offset (oscillates perpendicular to diagonal)
        const sineOffset = Math.sin(t * sineFrequency) * sineAmplitude;

        // Random offset within band width
        const bandOffset = (Math.random() - 0.5) * bandWidth + sineOffset;

        // Final position
        const x = baseX + perpX * bandOffset;
        const y = baseY + perpY * bandOffset;

        // Check bounds and overlap (reduced padding for more density)
        if (x >= 30 && x <= paper.view.size.width - 30 &&
            y >= 30 && y <= paper.view.size.height - 30 &&
            !isTooClose(x, y, generatedShapes)) {

          // Equal distribution: cycle through shape types
          const type = shapeTypes[shapeCounter % shapeTypes.length];
          shapeCounter++;

          const sizeOptions = sizes[type as keyof typeof sizes];
          const size = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];

          // Equal distribution: cycle through colors
          const strokeColor = colorOptions[colorCounter % colorOptions.length];
          colorCounter++;

          // Equal distribution: cycle through stroke widths
          const strokeWidth = strokeWidthOptions[strokeCounter % strokeWidthOptions.length];
          strokeCounter++;

          // Random rotation
          const rotation = Math.random() * 360;

          // Add shape
          if (type === 'circle') {
            generatedShapes.push({
              type: 'circle',
              x, y,
              radius: size,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'rect') {
            generatedShapes.push({
              type: 'rect',
              x, y,
              width: size,
              height: size,
              radius: Math.random() > 0.5 ? 2.5 : 4.5,
              rotation,
              strokeColor,
              strokeWidth
            });
          } else if (type === 'triangle') {
            generatedShapes.push({
              type: 'triangle',
              x, y,
              size,
              rotation,
              strokeColor,
              strokeWidth
            });
          }
        }
      }

      return generatedShapes;
    };

    const shapesData = generateShapesInDiagonalBand();

    // Draw visible sine wave band for debugging/visualization
    const drawSineWaveBand = () => {
      // Band parameters (must match generation parameters)
      const bandWidth = 300;
      const sineAmplitude = 100;
      const sineFrequency = 0.004;

      // Diagonal line from bottom-left to top-right
      const startPoint = { x: 0, y: paper.view.size.height };
      const endPoint = { x: paper.view.size.width, y: 0 };

      // Calculate diagonal distance
      const diagonalLength = Math.sqrt(
        Math.pow(endPoint.x - startPoint.x, 2) +
        Math.pow(endPoint.y - startPoint.y, 2)
      );

      // Unit vector along diagonal
      const directionX = (endPoint.x - startPoint.x) / diagonalLength;
      const directionY = (endPoint.y - startPoint.y) / diagonalLength;

      // Perpendicular vector (for band width)
      const perpX = -directionY;
      const perpY = directionX;

      // Draw center sine wave line
      const centerLine = new paper.Path();
      centerLine.strokeColor = new paper.Color('#FF0000');
      centerLine.strokeWidth = 2;
      centerLine.opacity = 0.3;
      centerLine.dashArray = [10, 5];

      // Draw upper boundary
      const upperBoundary = new paper.Path();
      upperBoundary.strokeColor = new paper.Color('#00FF00');
      upperBoundary.strokeWidth = 1;
      upperBoundary.opacity = 0.2;
      upperBoundary.dashArray = [5, 5];

      // Draw lower boundary
      const lowerBoundary = new paper.Path();
      lowerBoundary.strokeColor = new paper.Color('#00FF00');
      lowerBoundary.strokeWidth = 1;
      lowerBoundary.opacity = 0.2;
      lowerBoundary.dashArray = [5, 5];

      // Generate points along the diagonal
      for (let t = 0; t <= diagonalLength; t += 5) {
        // Position along the diagonal
        const baseX = startPoint.x + directionX * t;
        const baseY = startPoint.y + directionY * t;

        // Sine wave offset
        const sineOffset = Math.sin(t * sineFrequency) * sineAmplitude;

        // Center line point
        const centerX = baseX + perpX * sineOffset;
        const centerY = baseY + perpY * sineOffset;
        centerLine.add(new paper.Point(centerX, centerY));

        // Upper boundary point
        const upperOffset = sineOffset + bandWidth / 2;
        const upperX = baseX + perpX * upperOffset;
        const upperY = baseY + perpY * upperOffset;
        upperBoundary.add(new paper.Point(upperX, upperY));

        // Lower boundary point
        const lowerOffset = sineOffset - bandWidth / 2;
        const lowerX = baseX + perpX * lowerOffset;
        const lowerY = baseY + perpY * lowerOffset;
        lowerBoundary.add(new paper.Point(lowerX, lowerY));
      }

      // Return paths so they can be toggled later
      return { centerLine, upperBoundary, lowerBoundary };
    };

    // Draw the sine wave visualization
    const sineWaveGuides = drawSineWaveBand();

    // TOGGLE GUIDE VISIBILITY: Set to false to hide the sine wave guides
    const showGuides = true;
    if (!showGuides) {
      sineWaveGuides.centerLine.visible = false;
      sineWaveGuides.upperBoundary.visible = false;
      sineWaveGuides.lowerBoundary.visible = false;
    }

    // Fallback to original shapes if generation fails
    const originalShapesData = [
      // CENTER SHAPES - positioned around viewport center (683, 386)
      // Top circle
      { type: 'circle', x: 712.738, y: 271.64, radius: 69.5, strokeColor: colors.primaryLight, strokeWidth: 5 },
      // Bottom circle
      { type: 'circle', x: 670.738, y: 524.64, radius: 69.5, strokeColor: colors.primaryLight, strokeWidth: 5 },
      // Rectangle (square)
      { type: 'rect', x: 493.849 + 62, y: 270.26 + 62, width: 124, height: 124, radius: 17.5, rotation: -16.6403, strokeColor: colors.primaryLight, strokeWidth: 5 },
      { type: 'rect', x: 848.255, y: 331.91, width: 24, height: 24, radius: 2.5, rotation: 22.6612, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'rect', x: 902.214, y: 376.752, width: 40, height: 40, radius: 2.5, rotation: -34.4661, strokeColor: colors.accent, strokeWidth: 5 },

      // More circles
      { type: 'circle', x: 1083.24, y: 154.14, radius: 23, strokeColor: colors.secondary, strokeWidth: 5 },
      { type: 'circle', x: 1043.74, y: 239.64, radius: 15, strokeColor: colors.white, strokeWidth: 2 },
      { type: 'circle', x: 854.738, y: 418.64, radius: 15, strokeColor: colors.white, strokeWidth: 2 },

      // CENTER SHAPE - Triangle
      { type: 'triangle', x: 811.616, y: 439.128, size: 40, rotation: 15, strokeColor: colors.primaryLight, strokeWidth: 5 },
      { type: 'triangle', x: 1155.61, y: 135.053, size: 20, rotation: 0, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'triangle', x: 839.168, y: 259.237, size: 25, rotation: 45, strokeColor: colors.accent, strokeWidth: 5 },

      // More rectangles
      { type: 'rect', x: 866.216, y: 233.772, width: 24, height: 24, radius: 2.5, rotation: -34.6751, strokeColor: colors.tertiary, strokeWidth: 5 },
      { type: 'rect', x: 980.53, y: 168.411, width: 40, height: 40, radius: 2.5, rotation: -7.1514, strokeColor: colors.white, strokeWidth: 5 },

      // More circles
      { type: 'circle', x: 981.238, y: 309.14, radius: 23, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'circle', x: 898.738, y: 303.64, radius: 15.5, strokeColor: colors.accent, strokeWidth: 1 },

      // Bottom left shapes
      { type: 'rect', x: 396.18, y: 505.294, width: 28, height: 28, radius: 4.5, rotation: 22.6612, strokeColor: colors.tertiary, strokeWidth: 1 },
      { type: 'rect', x: 271.433, y: 610.235, width: 44, height: 44, radius: 4.5, rotation: -34.4661, strokeColor: colors.white, strokeWidth: 1 },
      { type: 'circle', x: 388.238, y: 591.14, radius: 23, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'circle', x: 301.738, y: 681.64, radius: 13.5, strokeColor: colors.accent, strokeWidth: 5 },

      // Middle shapes
      { type: 'triangle', x: 515.168, y: 375.237, size: 30, rotation: 30, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'rect', x: 527.216, y: 521.772, width: 24, height: 24, radius: 2.5, rotation: -34.6751, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'rect', x: 466.855, y: 552.109, width: 43, height: 43, radius: 4, rotation: -7.1514, strokeColor: colors.accent, strokeWidth: 2 },
      { type: 'circle', x: 506.238, y: 460.14, radius: 24.5, strokeColor: colors.tertiary, strokeWidth: 2 },
      { type: 'circle', x: 429.738, y: 463.64, radius: 13.5, strokeColor: colors.white, strokeWidth: 5 },

      // Right side shapes
      { type: 'rect', x: 1349.49, y: 92.4186, width: 24, height: 24, radius: 2.5, rotation: -141.68, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'rect', x: 1332.67, y: 39.6765, width: 40, height: 40, radius: 2.5, rotation: 161.193, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'circle', x: 1120.17, y: 252.076, radius: 23, strokeColor: colors.secondary, strokeWidth: 5 },
      { type: 'circle', x: 1132.46, y: 100.364, radius: 15, strokeColor: colors.white, strokeWidth: 2 },

      // Lines
      { type: 'line', x1: 1033.27, y1: 289.64, x2: 1043.88, y2: 300.246, strokeColor: colors.accentDark, strokeWidth: 5 },
      { type: 'line', x1: 1159.92, y1: 83.182, x2: 1152.57, y2: 70.1062, strokeColor: colors.accentDark, strokeWidth: 5 },
      { type: 'line', x1: 439.777, y1: 413.447, x2: 453.622, y2: 419.218, strokeColor: colors.accentDark, strokeWidth: 5 },

      // Bottom shapes
      { type: 'rect', x: 175.891, y: 772.016, width: 28, height: 28, radius: 4.5, rotation: -103.529, strokeColor: colors.tertiary, strokeWidth: 1 },
      { type: 'rect', x: 139.997, y: 637.01, width: 44, height: 44, radius: 4.5, rotation: 174.929, strokeColor: colors.white, strokeWidth: 1 },
      { type: 'circle', x: 117.317, y: 718.219, radius: 23, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'circle', x: 171.788, y: 667.689, radius: 13.5, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'rect', x: 37.1284, y: 665.948, width: 43, height: 43, radius: 4, rotation: -150.891, strokeColor: colors.accent, strokeWidth: 2 },
      { type: 'circle', x: 40.7876, y: 756.689, radius: 13.5, strokeColor: colors.white, strokeWidth: 5 },

      // Additional middle triangles
      { type: 'triangle', x: 924.924, y: 158.046, size: 20, rotation: 60, strokeColor: colors.accent, strokeWidth: 1 },
      { type: 'triangle', x: 952.3, y: 217.749, size: 25, rotation: -30, strokeColor: colors.tertiary, strokeWidth: 2 },
      { type: 'triangle', x: 355.151, y: 653.265, size: 20, rotation: 90, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'triangle', x: 475.147, y: 503.033, size: 22, rotation: 120, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'triangle', x: 217.204, y: 662.321, size: 28, rotation: -45, strokeColor: colors.secondary, strokeWidth: 5 },
      { type: 'triangle', x: 226.481, y: 612.15, size: 18, rotation: 180, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'triangle', x: 17.1423, y: 703.352, size: 25, rotation: 270, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'triangle', x: 289.913, y: 555.278, size: 30, rotation: 15, strokeColor: colors.secondary, strokeWidth: 5 },
      { type: 'triangle', x: 1087.4, y: 222.868, size: 22, rotation: -60, strokeColor: colors.accent, strokeWidth: 5 },
      { type: 'triangle', x: 1228.73, y: 239.136, size: 26, rotation: 45, strokeColor: colors.accent, strokeWidth: 1 },
      { type: 'triangle', x: 1218.49, y: 174.26, size: 24, rotation: 135, strokeColor: colors.tertiary, strokeWidth: 2 },

      // More rectangles
      { type: 'rect', x: 1323.43, y: 178.508, width: 24, height: 24, radius: 2.5, rotation: 160.984, strokeColor: colors.tertiary, strokeWidth: 5 },
      { type: 'rect', x: 1177.99, y: 214.147, width: 40, height: 40, radius: 2.5, rotation: -171.493, strokeColor: colors.white, strokeWidth: 5 },

      // Final circles
      { type: 'circle', x: 1215.29, y: 78.4505, radius: 23, strokeColor: colors.white, strokeWidth: 5 },
      { type: 'circle', x: 1293.25, y: 106.014, radius: 15.5, strokeColor: colors.accent, strokeWidth: 1 },
    ];

    // Create shapes
    const shapes: paper.Path[] = [];

    shapesData.forEach(shapeData => {
      let shape: paper.Path | paper.Shape;

      switch(shapeData.type) {
        case 'circle':
          shape = new paper.Path.Circle({
            center: [shapeData.x, shapeData.y],
            radius: shapeData.radius,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          break;

        case 'rect':
          shape = new paper.Path.Rectangle({
            point: [shapeData.x - shapeData.width/2, shapeData.y - shapeData.height/2],
            size: [shapeData.width, shapeData.height],
            radius: shapeData.radius || 0,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          // Set position to center after creation
          shape.position = new paper.Point(shapeData.x, shapeData.y);
          if (shapeData.rotation) {
            shape.rotate(shapeData.rotation, shape.position);
          }
          break;

        case 'triangle':
          shape = new paper.Path.RegularPolygon({
            center: [shapeData.x, shapeData.y],
            sides: 3,
            radius: shapeData.size,
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
          });
          if (shapeData.rotation) {
            shape.rotate(shapeData.rotation);
          }
          break;

        case 'line':
          shape = new paper.Path.Line({
            from: [shapeData.x1, shapeData.y1],
            to: [shapeData.x2, shapeData.y2],
            strokeColor: shapeData.strokeColor,
            strokeWidth: shapeData.strokeWidth,
            strokeCap: 'round',
          });
          break;

        default:
          return;
      }

      // Store original position and lifecycle data
      shape.data = {
        originalPosition: shape.position.clone(),
        originalRotation: shapeData.rotation || 0,
        floatPhaseY: Math.random() * Math.PI * 2, // Y-axis phase
        floatPhaseX: Math.random() * Math.PI * 2, // X-axis phase (different)
        rotationSpeed: (Math.random() - 0.5) * 0.02, // Slightly more visible rotation
        floatSpeedY: 0.02 + Math.random() * 0.02, // Increased Y speed
        floatSpeedX: 0.01 + Math.random() * 0.01, // Increased X speed
        amplitudeY: 1 + Math.random() * 3, // Random Y amplitude (5-8px)
        amplitudeX: 1 + Math.random() * .03, // Random X amplitude (6-10px)
        // Lifecycle properties
        age: 0,
        lifespan: 300 + Math.random() * 500, // Random lifespan (300-800 frames, ~5-13 seconds at 60fps)
        baseX: shapeData.x, // Original X for respawn
        baseY: shapeData.y, // Original Y for respawn
        shapeType: shapeData.type,
        // Firing properties
        isFiring: false,
        fireIntensity: 0,
        fireDecay: 0.05, // How fast the glow fades
        originalStrokeWidth: shapeData.strokeWidth,
        originalStrokeColor: shapeData.strokeColor,
        lastFireTime: -1000, // Last time this shape fired (frame number)
        fireCooldown: 180, // Minimum frames between fires (3 seconds at 60fps)
        lifespanExtension: 100, // Frames added to lifespan when firing (~1.7 seconds)
      };

      shapes.push(shape);
    });

    console.log(`Created ${shapes.length} shapes`);

    // Create neuron-like connections between nearby shapes
    const connections: any[] = [];
    const maxConnectionDistance = 150; // Maximum distance to connect shapes
    const connectionProbability = 0.3; // Probability of creating a connection

    const createConnections = () => {
      shapes.forEach((shape, i) => {
        shapes.forEach((otherShape, j) => {
          if (i >= j) return; // Avoid duplicate connections and self-connections

          const dx = otherShape.position.x - shape.position.x;
          const dy = otherShape.position.y - shape.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Only connect if within range and moving towards top-right direction
          // (target shape should be to the right and/or above)
          if (distance < maxConnectionDistance &&
              (dx > 0 || dy < 0) && // Right or up
              Math.random() < connectionProbability) {

            const line = new paper.Path.Line({
              from: shape.position,
              to: otherShape.position,
              strokeColor: new paper.Color(colors.secondary),
              strokeWidth: 0.5,
              opacity: 0.2,
              dashArray: [2, 4],
            });

            // Store connection data
            line.data = {
              startShape: shape,
              endShape: otherShape,
              age: Math.random() * 60, // Random starting age for staggered animation
              pulseSpeed: 0.05 + Math.random() * 0.05,
              travelingPulses: [], // Array of pulses traveling along this connection
            };

            connections.push(line);
          }
        });
      });
    };

    createConnections();
    console.log(`Created ${connections.length} neuron connections`);

    // Regenerate connections for a specific shape
    const regenerateConnectionsForShape = (shape: paper.Path, index: number) => {
      // Create new connections FROM this shape to nearby shapes (outgoing)
      shapes.forEach((otherShape, j) => {
        if (index === j) return; // Skip self

        const dx = otherShape.position.x - shape.position.x;
        const dy = otherShape.position.y - shape.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Only connect if within range and moving towards top-right direction
        if (distance < maxConnectionDistance &&
            (dx > 0 || dy < 0) && // Right or up
            Math.random() < connectionProbability) {

          const line = new paper.Path.Line({
            from: shape.position,
            to: otherShape.position,
            strokeColor: new paper.Color(colors.secondary),
            strokeWidth: 0.5,
            opacity: 0.2,
            dashArray: [2, 4],
          });

          line.data = {
            startShape: shape,
            endShape: otherShape,
            age: Math.random() * 60,
            pulseSpeed: 0.05 + Math.random() * 0.05,
            travelingPulses: [],
          };

          connections.push(line);
        }
      });

      // Create new connections TO this shape from nearby shapes (incoming)
      shapes.forEach((otherShape, j) => {
        if (index === j) return; // Skip self

        const dx = shape.position.x - otherShape.position.x;
        const dy = shape.position.y - otherShape.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Only connect if within range and moving towards top-right direction
        if (distance < maxConnectionDistance &&
            (dx > 0 || dy < 0) && // Right or up
            Math.random() < connectionProbability) {

          const line = new paper.Path.Line({
            from: otherShape.position,
            to: shape.position,
            strokeColor: new paper.Color(colors.secondary),
            strokeWidth: 0.5,
            opacity: 0.2,
            dashArray: [2, 4],
          });

          line.data = {
            startShape: otherShape,
            endShape: shape,
            age: Math.random() * 60,
            pulseSpeed: 0.05 + Math.random() * 0.05,
            travelingPulses: [],
          };

          connections.push(line);
        }
      });
    };

    // Counters for equal distribution of shapes, colors, and stroke widths
    let shapeTypeCounter = 0;
    let colorCounter = 0;
    let strokeWidthCounter = 0;

    // Easing functions for smoother motion
    const easeInOutSine = (t: number) => -(Math.cos(Math.PI * t) - 1) / 2;
    const easeInOutQuad = (t: number) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    const easeInOutCubic = (t: number) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

    // Helper function to regenerate a shape with equal distribution
    const regenerateShape = (shape: paper.Path, index: number) => {
      const data = shape.data;
      const oldShape = shape; // Store reference to old shape before removal

      // Remove all connections that reference this old shape
      for (let i = connections.length - 1; i >= 0; i--) {
        const conn = connections[i];
        if (conn.data.startShape === oldShape || conn.data.endShape === oldShape) {
          // Clean up any traveling pulses
          conn.data.travelingPulses.forEach((pulse: any) => {
            if (pulse.segment) {
              pulse.segment.remove();
            }
          });
          conn.remove();
          connections.splice(i, 1);
        }
      }

      // Use exact original position (no jitter)
      const jitterX = 0;
      const jitterY = 0;
      const newX = data.baseX + jitterX;
      const newY = data.baseY + jitterY;

      // Equal distribution of shape types (cycle through)
      const shapeTypes = ['circle', 'rect', 'triangle'];
      const newType = shapeTypes[shapeTypeCounter % shapeTypes.length];
      shapeTypeCounter++;

      // Equal distribution of sizes for each type
      const sizes = { circle: [15, 20, 10], rect: [15, 25, 20], triangle: [20, 15, 25] };
      const sizeOptions = sizes[newType as keyof typeof sizes];
      const sizeIndex = Math.floor(Math.random() * sizeOptions.length); // Keep size random within type
      const newSize = sizeOptions[sizeIndex] || 20;

      // Equal distribution of colors (cycle through)
      const colorOptions = [colors.primaryLight, colors.secondary, colors.accent, colors.tertiary, colors.white];
      const newColor = colorOptions[colorCounter % colorOptions.length];
      colorCounter++;

      // Equal distribution of stroke widths (cycle through)
      const strokeWidthOptions = [1, 2, 5];
      const newStrokeWidth = strokeWidthOptions[strokeWidthCounter % strokeWidthOptions.length];
      strokeWidthCounter++;

      // Random rotation
      const newRotation = Math.random() * 360;

      // Remove old shape
      shape.remove();

      // Create new shape
      let newShape: paper.Path | paper.Shape;

      switch(newType) {
        case 'circle':
          newShape = new paper.Path.Circle({
            center: [newX, newY],
            radius: newSize,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          break;

        case 'rect':
          newShape = new paper.Path.Rectangle({
            point: [newX - newSize/2, newY - newSize/2],
            size: [newSize, newSize],
            radius: Math.random() > 0.5 ? 2.5 : 4.5,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          newShape.position = new paper.Point(newX, newY);
          newShape.rotate(newRotation, newShape.position);
          break;

        case 'triangle':
          newShape = new paper.Path.RegularPolygon({
            center: [newX, newY],
            sides: 3,
            radius: newSize,
            strokeColor: newColor,
            strokeWidth: newStrokeWidth,
          });
          newShape.rotate(newRotation);
          break;

        default:
          return;
      }

      // Reset lifecycle data with new randomized values
      newShape.data = {
        originalPosition: newShape.position.clone(),
        originalRotation: newRotation,
        floatPhaseY: Math.random() * Math.PI * 2,
        floatPhaseX: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.02,
        floatSpeedY: 0.02 + Math.random() * 0.02,
        floatSpeedX: 0.01 + Math.random() * 0.01,
        amplitudeY: 1 + Math.random() * 3,
        amplitudeX: 1 + Math.random() * .03,
        age: 0,
        lifespan: 300 + Math.random() * 500, // New random lifespan
        baseX: data.baseX, // Keep original base position
        baseY: data.baseY,
        shapeType: newType,
        // Firing properties
        isFiring: false,
        fireIntensity: 0,
        fireDecay: 0.05,
        originalStrokeWidth: newStrokeWidth,
        originalStrokeColor: newColor,
        lastFireTime: -1000,
        fireCooldown: 180,
        lifespanExtension: 100,
      };

      // Replace in shapes array
      shapes[index] = newShape;

      // Regenerate connections for this new shape
      regenerateConnectionsForShape(newShape, index);
    };

    // Helper function to trigger a shape to fire
    const fireShape = (shape: paper.Path, currentFrame: number) => {
      // Safety check: ensure shape is still valid and in the shapes array
      if (!shape || !shape.data || !shapes.includes(shape)) {
        return;
      }

      // Check cooldown: prevent firing too frequently
      const timeSinceLastFire = currentFrame - shape.data.lastFireTime;
      if (timeSinceLastFire < shape.data.fireCooldown) {
        return; // Still in cooldown, don't fire
      }

      if (!shape.data.isFiring) {
        shape.data.isFiring = true;
        shape.data.fireIntensity = 1.0;
        shape.data.lastFireTime = currentFrame; // Update last fire time

        // Extend lifespan - active neurons live longer
        shape.data.lifespan += shape.data.lifespanExtension;

        // Send pulses along all outgoing connections
        connections.forEach((connection) => {
          if (connection.data.startShape === shape) {
            // Add a traveling pulse
            connection.data.travelingPulses.push({
              progress: 0, // 0 = start, 1 = end
              speed: 0.02, // Speed of pulse travel (0.02 = 2% per frame)
            });
          }
        });
      }
    };

    // Track current frame for mouse interaction
    let currentFrameCount = 0;

    // Organic floating animations - each shape moves independently in X and Y with easing
    paper.view.onFrame = (event: any) => {
      const time = event.count;
      currentFrameCount = time;

      // Randomly trigger fires from shapes (neural activity) - reduced frequency
      if (Math.random() < 0.003) { // 0.3% chance per frame = ~0.18 fires per second
        const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
        if (randomShape) {
          fireShape(randomShape, time);
        }
      }

      shapes.forEach((shape, index) => {
        // Regenerate before incrementing age if lifecycle is complete
        if (shape.data.age >= shape.data.lifespan) {
          regenerateShape(shape, index);
          // Get the newly regenerated shape
          const regeneratedShape = shapes[index];
          if (!regeneratedShape) return;
          shape = regeneratedShape;
        }

        // Increment age
        shape.data.age++;

        // Calculate fade in/out opacity based on lifecycle (linear)
        const fadeInDuration = 30; // Fade in over 30 frames (~0.5 second at 60fps)
        const fadeOutDuration = 30; // Fade out over 30 frames
        const age = shape.data.age;
        const lifespan = shape.data.lifespan;

        let opacity = 1;

        // Fade in at the beginning (linear)
        if (age <= fadeInDuration) {
          opacity = age / fadeInDuration;
        }
        // Fade out at the end (linear)
        else if (age >= lifespan - fadeOutDuration) {
          opacity = Math.max(0, (lifespan - age) / fadeOutDuration);
        }

        shape.opacity = opacity;

        // Handle firing state (glow effect)
        if (shape.data.isFiring) {
          shape.data.fireIntensity -= shape.data.fireDecay;
          if (shape.data.fireIntensity <= 0) {
            shape.data.isFiring = false;
            shape.data.fireIntensity = 0;
          }
        }

        // Apply glow effect when firing, or restore to normal
        if (shape.data.fireIntensity > 0) {
          // Increase stroke width to create glow
          shape.strokeWidth = shape.data.originalStrokeWidth + shape.data.fireIntensity * 3;

          // Brighten the color
          const glowColor = new paper.Color(shape.data.originalStrokeColor);
          glowColor.brightness += shape.data.fireIntensity * 0.3;
          shape.strokeColor = glowColor;
        } else {
          // Restore to original appearance when not firing
          shape.strokeWidth = shape.data.originalStrokeWidth;
          shape.strokeColor = new paper.Color(shape.data.originalStrokeColor);
        }

        // Raw sine wave values (oscillating between -1 and 1)
        const rawSinY = Math.sin(time * shape.data.floatSpeedY + shape.data.floatPhaseY);
        const rawSinX = Math.sin(time * shape.data.floatSpeedX + shape.data.floatPhaseX);

        // Normalize to 0-1 range for easing function
        const normalizedY = (rawSinY + 1) / 2; // Convert -1..1 to 0..1
        const normalizedX = (rawSinX + 1) / 2;

        // Apply easing (creates smoother acceleration/deceleration)
        const easedY = easeInOutSine(normalizedY);
        const easedX = easeInOutSine(normalizedX);

        // Convert back to -1..1 range and apply amplitude
        const floatOffsetY = (easedY * 2 - 1) * shape.data.amplitudeY;
        const floatOffsetX = (easedX * 2 - 1) * shape.data.amplitudeX;

        // Apply both movements
        shape.position.x = shape.data.originalPosition.x + floatOffsetX;
        shape.position.y = shape.data.originalPosition.y + floatOffsetY;

        // Gentle rotation with easing
        const rotationEase = easeInOutSine(normalizedY);
        shape.rotate(shape.data.rotationSpeed * 60 * (rotationEase * 2 - 1));
      });

      // Animate neuron connections
      for (let i = connections.length - 1; i >= 0; i--) {
        const connection = connections[i];

        // Safety check: ensure both shapes are still valid
        const startShape = connection.data.startShape;
        const endShape = connection.data.endShape;

        if (!startShape || !endShape || !shapes.includes(startShape) || !shapes.includes(endShape)) {
          // Clean up invalid connection
          connection.data.travelingPulses.forEach((pulse: any) => {
            if (pulse.segment) pulse.segment.remove();
          });
          connection.remove();
          connections.splice(i, 1);
          continue;
        }

        // Update connection positions to follow shapes
        const startPos = startShape.position;
        const endPos = endShape.position;
        connection.segments[0].point = startPos;
        connection.segments[1].point = endPos;

        // Pulsing opacity animation (like neurons firing)
        connection.data.age += connection.data.pulseSpeed;
        const pulseValue = Math.sin(connection.data.age);
        const baseOpacity = 0.15;
        const pulseAmount = 0.15;
        connection.opacity = baseOpacity + (pulseValue * 0.5 + 0.5) * pulseAmount;

        // Make connections fade with their connected shapes
        const startOpacity = connection.data.startShape.opacity;
        const endOpacity = connection.data.endShape.opacity;
        const minShapeOpacity = Math.min(startOpacity, endOpacity);
        connection.opacity *= minShapeOpacity;

        // Animate traveling pulses
        const pulses = connection.data.travelingPulses;
        for (let i = pulses.length - 1; i >= 0; i--) {
          const pulse = pulses[i];
          pulse.progress += pulse.speed;

          // Create a highlighted segment of the connection line for the pulse
          const pulseLength = 0.15; // Length of the pulse segment (15% of line)
          const pulseStart = Math.max(0, pulse.progress - pulseLength);
          const pulseEnd = Math.min(1, pulse.progress);

          // Interpolate color from start shape to end shape based on progress
          const startColor = new paper.Color(startShape.strokeColor);
          const endColor = new paper.Color(endShape.strokeColor);
          const pulseColor = startColor.clone();

          // Lerp between start and end color based on pulse progress
          pulseColor.red = startColor.red + (endColor.red - startColor.red) * pulse.progress;
          pulseColor.green = startColor.green + (endColor.green - startColor.green) * pulse.progress;
          pulseColor.blue = startColor.blue + (endColor.blue - startColor.blue) * pulse.progress;

          if (!pulse.segment) {
            pulse.segment = new paper.Path.Line({
              from: startPos.add(endPos.subtract(startPos).multiply(pulseStart)),
              to: startPos.add(endPos.subtract(startPos).multiply(pulseEnd)),
              strokeColor: pulseColor,
              strokeWidth: 2,
              strokeCap: 'round',
            });
          } else {
            // Update segment position and color
            pulse.segment.segments[0].point = startPos.add(endPos.subtract(startPos).multiply(pulseStart));
            pulse.segment.segments[1].point = startPos.add(endPos.subtract(startPos).multiply(pulseEnd));
            pulse.segment.strokeColor = pulseColor;
          }

          // Fade as it travels
          pulse.segment.opacity = 0.9 * (1 - pulse.progress * 0.3);

          // If pulse reached the end, trigger the next shape to fire
          if (pulse.progress >= 1) {
            fireShape(connection.data.endShape, time);
            if (pulse.segment) {
              pulse.segment.remove(); // Clean up the pulse segment
            }
            pulses.splice(i, 1); // Remove completed pulse
          }
        }
      }
    };

    console.log('Animation loop started');

    // Mouse interaction - fire nodes on hover
    let lastHoveredShape: paper.Path | null = null;

    paper.view.onMouseMove = (event: any) => {
      const hitResult = paper.project.hitTest(event.point, {
        fill: true,
        stroke: true,
        tolerance: 5
      });

      if (hitResult && hitResult.item) {
        // Check if the hit item is one of our shapes
        const hoveredShape = shapes.find(s => s === hitResult.item);

        if (hoveredShape && hoveredShape !== lastHoveredShape) {
          // Fire the shape when mouse enters it
          fireShape(hoveredShape, currentFrameCount);
          lastHoveredShape = hoveredShape;
        }
      } else {
        // Mouse is not over any shape
        lastHoveredShape = null;
      }
    };

    // Handle resize
    window.addEventListener('resize', () => {
      paper.view.viewSize = new paper.Size(window.innerWidth, window.innerHeight);
    });
  }

  // Run when DOM is ready
  console.log('Script loaded! readyState:', document.readyState);

  if (document.readyState === 'loading') {
    console.log('Waiting for DOMContentLoaded...');
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded fired!');
      initPaperCanvas();
    });
  } else {
    console.log('DOM already ready, initializing immediately');
    initPaperCanvas();
  }
</script>